<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.functions package &mdash; Compact Poisson Filters 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="src.helper package" href="src.helper.html" />
    <link rel="prev" title="src.demos package" href="src.demos.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Compact Poisson Filters
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes.html">Notes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Code</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="code_doc.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="src.demos.html">src.demos package</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">src.functions package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-src.functions.analytics">src.functions.analytics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-src.functions.decompositions">src.functions.decompositions module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#technicals">Technicals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-src.functions.generator">src.functions.generator module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generator-method">Technicals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-src.functions.mathlib">src.functions.mathlib module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mathlib-technicals">Technicals</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="src.helper.html">src.helper package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="code_index.html">Indices and tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Compact Poisson Filters</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="code_doc.html">Documentation</a> &raquo;</li>
      <li>src.functions package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/src.functions.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="src-functions-package">
<h1>src.functions package<a class="headerlink" href="#src-functions-package" title="Permalink to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-src.functions.analytics">
<span id="src-functions-analytics-module"></span><h2>src.functions.analytics module<a class="headerlink" href="#module-src.functions.analytics" title="Permalink to this heading"></a></h2>
<dl class="field-list simple">
<dt class="field-odd">author</dt>
<dd class="field-odd"><p>Shahin (Amir Hossein) Rabbani</p>
</dd>
<dt class="field-even">contact</dt>
<dd class="field-even"><p><a class="reference external" href="mailto:shahin&#46;rab&#37;&#52;&#48;gmail&#46;com">shahin<span>&#46;</span>rab<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt class="field-odd">copyright</dt>
<dd class="field-odd"><p>See <a class="reference internal" href="license.html#license-page"><span class="std std-ref">License</span></a></p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="src.functions.analytics.compare_jacobi_3methods_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.analytics.</span></span><span class="sig-name descname"><span class="pre">compare_jacobi_3methods_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.analytics.compare_jacobi_3methods_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compare solutions to the 2D Poisson equation for 3 cases: Jacobi in the <em>matrix form</em> vs <em>vector form</em>     vs <em>Poisson Filters</em> method (convolution, reduced or full kernel).     No boundary treatment is done, which means data domain is treated as infinite domain.</p>
<p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">demos.convergence.demo_3methods_comparison_no_bc_2d()</span></code> for the example demo.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">err_abs_jm_vs_jv</span></code> : absolute error Jacobi matrix form vs Jacobi vector form</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_rel_jm_vs_jv</span></code> : relative error Jacobi matrix form vs Jacobi vector form in percent</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_abs_jv_vs_pk</span></code> : absolute error Jacobi vector form vs Poisson kernel</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_rel_jv_vs_pk</span></code> : relative error Jacobi vector form vs Poisson kernel in percent</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_abs_jm_vs_pk</span></code> : absolute error Jacobi matrix form vs Poisson kernel</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_rel_jm_vs_pk</span></code> : relative error Jacobi matrix form vs Poisson kernel in percent</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">jacobi_solution_matrix_form</span></code> : Jacobi solution in matrix form</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">jacobi_solution_vector_form</span></code> : Jacobi solution in vector form</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">poisson_solution</span></code> : Poisson kernel solution</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">data_padded</span></code> : generate sample data</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.analytics.compare_jacobi_3methods_neumann_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.analytics.</span></span><span class="sig-name descname"><span class="pre">compare_jacobi_3methods_neumann_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.analytics.compare_jacobi_3methods_neumann_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compare solutions to the 2D Poisson equation for 3 cases: Jacobi in the <em>matrix form</em> vs <em>vector form</em>     vs <em>Poisson Filters</em> method (convolution, reduced or full kernel).</p>
<p>This is with Neumann boundary treatment.</p>
<p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">demos.convergence.demo_3methods_comparison_no_bc_2d()</span></code> for the example demo.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">err_abs_jm_vs_jv</span></code> : absolute error Jacobi matrix form vs Jacobi vector form</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_rel_jm_vs_jv</span></code> : relative error Jacobi matrix form vs Jacobi vector form in percent</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_abs_jv_vs_pk</span></code> : absolute error Jacobi vector form vs Poisson kernel</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_rel_jv_vs_pk</span></code> : relative error Jacobi vector form vs Poisson kernel in percent</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_abs_jm_vs_pk</span></code> : absolute error Jacobi matrix form vs Poisson kernel</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_rel_jm_vs_pk</span></code> : relative error Jacobi matrix form vs Poisson kernel in percent</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">jacobi_solution_matrix_form</span></code> : Jacobi solution in matrix form</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">jacobi_matrix_form_residuals</span></code> : Jacobi solution in matrix form residuals</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">jacobi_solution_vector_form</span></code> : Jacobi solution in vector form</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">jacobi_vector_form_residuals</span></code> : Jacobi solution in vector form residuals</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">poisson_solution</span></code> : Poisson kernel solution</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">poisson_residual</span></code> : Poisson kernel solution residuals</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">data_padded</span></code> : generate sample data</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.analytics.compare_jacobi_poisson_neumann_edge_mirrored_correction_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.analytics.</span></span><span class="sig-name descname"><span class="pre">compare_jacobi_poisson_neumann_edge_mirrored_correction_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.analytics.compare_jacobi_poisson_neumann_edge_mirrored_correction_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compare ground truth Jacobi solution to Poisson filters solution (<em>only for inverse</em>) using tiled mirror
method to treat the Neumann boundary. This is the core principle of the <em>mirror marching</em> algorithm
proposed in the paper to do the boundary treatment.</p>
<p>The mirrored data tiles are automatically computed based on the target Jacobi iteration to make sure there is
enough padding for the base data matrix when doing the convolution.     See <code class="xref py py-func docutils literal notranslate"><span class="pre">demos.boundary.demo_wall_neumann_tiled_mirrored_2d()</span></code> for an example demo.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">jacobi_solution</span></code> : ground truth solution</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">poisson_solution</span></code> : Poisson filter solution</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">data_domain</span></code> : created data matrix</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">data_mirrored</span></code> : expanded data matrix used in the Poisson filters method</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">safe_rank</span></code> : computed safe rank after kernel reduction</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_abs</span></code> : absolute error</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">err_rel</span></code> : relative error</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.analytics.compute_adaptive_truncation_factors">
<span class="sig-prename descclassname"><span class="pre">src.functions.analytics.</span></span><span class="sig-name descname"><span class="pre">compute_adaptive_truncation_factors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filters_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.analytics.compute_adaptive_truncation_factors" title="Permalink to this definition"></a></dt>
<dd><p>Given a list of target iterations, collect info about the effective maximum number of     rank and filter size required for each iteration, for either 2D or 3D case.</p>
<p>In case of <code class="code docutils literal notranslate"><span class="pre">filters_iterations=None</span></code> force generate the filters, for a range of target iterations     <code class="code docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">max_itr]</span></code>, where <code class="code docutils literal notranslate"><span class="pre">max_itr</span></code> is the same as target iteration set in the options.</p>
<p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">demos.convergence.demo_adaptive_truncation_info_2d()</span></code> for the example demo.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Filters are assumed to be already truncated upon load or generation.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – </p></li>
<li><p><strong>filters_iterations</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – list of target iterations.         If filters are already available use this parameter, else (<code class="code docutils literal notranslate"><span class="pre">None</span></code>) force compute them.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>output will be a <code class="code docutils literal notranslate"><span class="pre">(max_itr,</span> <span class="pre">3)</span></code> shape,         with format <code class="code docutils literal notranslate"><span class="pre">(max_effective_rank,</span> <span class="pre">max_filter_size,</span> <span class="pre">actual_filter_size)</span></code>.
If in dynamic truncation mode return the analysis, else a zero vector with the size of <code class="code docutils literal notranslate"><span class="pre">max_itr</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.analytics.generate_collision_mask">
<span class="sig-prename descclassname"><span class="pre">src.functions.analytics.</span></span><span class="sig-name descname"><span class="pre">generate_collision_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_shape_boundary</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.analytics.generate_collision_mask" title="Permalink to this definition"></a></dt>
<dd><p>Create a 2D collision masks with the same size as the input data matrix. Walls are marked as both contours and     solids. Do cell marking for solid/contour/data for complex collider shapes, if loaded.</p>
<p>It is optional to load a complex shape, in which case we do proper sampling to best match the resolutions     of the loaded image and the domain matrix.</p>
<dl class="simple">
<dt>The mask marking convention:</dt><dd><ul class="simple">
<li><p>data domain = 0</p></li>
<li><p>solid = 1</p></li>
<li><p>contour = 2 (still part of solid, but with a special flag)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – 2D data domain</p></li>
<li><p><strong>path</strong> (<em>str</em>) – path to load the image of the complex object</p></li>
<li><p><strong>load_shape_boundary</strong> (<em>bool</em>) – load a complex object shape from file</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a collision mask with +1 flags for solid, and a contour mask for the contours around the
solid object with +2 flags.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.analytics.make_special_data_central_square">
<span class="sig-prename descclassname"><span class="pre">src.functions.analytics.</span></span><span class="sig-name descname"><span class="pre">make_special_data_central_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.analytics.make_special_data_central_square" title="Permalink to this definition"></a></dt>
<dd><p>Make a 2D data matrix with a non-zero box at the center and zero everywhere else.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>tuple</em>) – base size of the square matrix</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – not a circle radius, but the span length of the non-zeros in the central box. Take it as base         square length.</p></li>
<li><p><strong>value</strong> (<em>float</em>) – non-zero value to be assigned to the pattern</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2d data matrix with a non-zero box pattern at the center</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.analytics.prepare_padded_input_matrix">
<span class="sig-prename descclassname"><span class="pre">src.functions.analytics.</span></span><span class="sig-name descname"><span class="pre">prepare_padded_input_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.analytics.prepare_padded_input_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Cook up a data matrix (2D or 3D), either with randomized or constant values, with proper dynamic wall padding.</p>
<p>We expand the matrix to account for convolution shrinkage. This helps with     comparing the Jacobi and the Poisson kernel solutions as the two might end up     having different sizes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Check out <code class="xref py py-func docutils literal notranslate"><span class="pre">helper.commons.DataMatrixMode()</span></code> for choices of making the data matrix.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">data_padded</span></code>: padded (expanded) data matrix</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">data_domain</span></code>: original un-padded data matrix</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">padding_size</span></code>: computed padding size due to convolution shrinkage</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.analytics.solve_poisson_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.analytics.</span></span><span class="sig-name descname"><span class="pre">solve_poisson_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poisson_kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.analytics.solve_poisson_2d" title="Permalink to this definition"></a></dt>
<dd><p>General solver for 2D Poisson equation, for either <em>inverse</em> or <em>forward</em> Poisson.</p>
<p>The function supports solving the Poisson equation with the full kernel (input), reduced kernel (computed here),     or separable Poisson filters (computed here), depending on how parameters are set in the input options. Truncation     parameters will be retrieved from options as well.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To set rank, order, and other relevant parameters you need to pack <code class="code docutils literal notranslate"><span class="pre">OptionsKernel</span></code> and
<code class="code docutils literal notranslate"><span class="pre">OptionsReduction</span></code> in <code class="code docutils literal notranslate"><span class="pre">OptionsGeneral</span></code> and send it to this function.         These dataclasses are in <code class="code docutils literal notranslate"><span class="pre">helper.commons.py</span></code>.
To see how to pack options, look at main demos, or see <code class="xref py py-func docutils literal notranslate"><span class="pre">helper.commons.generic_options()</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2D domain matrix</p></li>
<li><p><strong>poisson_kernel</strong> (<em>ndarray</em>) – precomputed 2D Poisson kernel (<em>inverse</em> or <em>forward</em>)</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – </p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – number of lateral elements to skip in the convolution. This helps with saving computation
time when having redundant padding (<strong>Default=</strong> <code class="code docutils literal notranslate"><span class="pre">0</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>solution to the 2D Poisson equation, computed safe rank</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.analytics.subtract_contour_from_solid">
<span class="sig-prename descclassname"><span class="pre">src.functions.analytics.</span></span><span class="sig-name descname"><span class="pre">subtract_contour_from_solid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.analytics.subtract_contour_from_solid" title="Permalink to this definition"></a></dt>
<dd><p>Given a 2D solid object mask and its corresponding contour, extract the interior
part of the solid maks by subtracting the two masks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solid</strong> (<em>ndarray</em>) – 2d input matrix</p></li>
<li><p><strong>contour</strong> (<em>ndarray</em>) – 2d input matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new 2d matrix with marked interior cells by <code class="code docutils literal notranslate"><span class="pre">1</span></code>, else <code class="code docutils literal notranslate"><span class="pre">0</span></code></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-src.functions.decompositions">
<span id="src-functions-decompositions-module"></span><h2>src.functions.decompositions module<a class="headerlink" href="#module-src.functions.decompositions" title="Permalink to this heading"></a></h2>
<dl class="field-list simple">
<dt class="field-odd">author</dt>
<dd class="field-odd"><p>Shahin (Amir Hossein) Rabbani</p>
</dd>
<dt class="field-even">contact</dt>
<dd class="field-even"><p><a class="reference external" href="mailto:shahin&#46;rab&#37;&#52;&#48;gmail&#46;com">shahin<span>&#46;</span>rab<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt class="field-odd">copyright</dt>
<dd class="field-odd"><p>See <a class="reference internal" href="license.html#license-page"><span class="std std-ref">License</span></a></p>
</dd>
</dl>
<section id="technicals">
<span id="decomposition-method"></span><h3>Technicals<a class="headerlink" href="#technicals" title="Permalink to this heading"></a></h3>
<p>While in 2D the eigenvalues are sorted, it is not guaranteed to be true in 3D. This is due to the lack of consensus
on rank definition in tensor decomposition, and the fact that current symmetric CP algorithm used by our method, is
an iterative method that does its best to deal with a NP-hard problem.</p>
<p>This difference between 2D and 3D eigenvalues properties has an important implication in practice:</p>
<blockquote>
<div><ul class="simple">
<li><p>In 2D it is safe to generate, say, rank-8 filters and only use, for example, the first 3 to capture a         significant portion of the variance. The contribution of the 4th rank is expected to be less than the         first 3 ranks.</p></li>
<li><p>In 3D we might get different filters if we first get, say, rank-8 filters and choose the first 3, compared         to when we directly compute rank-3 filters and use all of them. In both cases we are interested in the first         3 ranks, but in the latter case results are expected to be numerically more stable. There is no guarantee         to get a decreasing variance contribution with higher ranks in 3D, just like what one would expect in 2D.</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt><em>Poisson filter computation from decomposition components</em></dt><dd><p>Check out <a class="reference internal" href="#src.functions.decompositions.get_filters_from_svd_components_2d" title="src.functions.decompositions.get_filters_from_svd_components_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_filters_from_svd_components_2d()</span></code></a> to see how we do filter computation. The same method
applied to 3D using <em>Sym-CP</em> and with an additional set of vectors for the 3rd dimension.</p>
</dd>
<dt><em>Absorbing eigenvalues in 2D and 3D</em></dt><dd><ul class="simple">
<li><p><strong>2D</strong> : Because the Poisson kernel is always square with non-negative eigenvalues, the singular values         obtained from SVD coincide with the eigenvalues. This is not true in general, and is only true in our case         given the aforementioned properties of the kernel. To absorb the eigenvalues in filters, we scale each of the         two ranked filters by         <span class="math notranslate nohighlight">\(\sqrt{\sigma_{r}}\)</span>, the eigenvalue corresponding to rank <span class="math notranslate nohighlight">\(r\)</span>.</p></li>
<li><p><strong>3D</strong> : Symmetric-CP decomposition of 3D Poisson kernel gives a set of factors and cores, where cores can         be taken as the best approximation of true tensor eigenvalues (this should always be taken with a grain of          salt for tensor eigen decomposition). To absorb the eigenvalues in filters, we scale each of the three         ranked filters by <span class="math notranslate nohighlight">\(\sqrt[3]{\sigma_{r}}\)</span>, the eigenvalue corresponding to rank <span class="math notranslate nohighlight">\(r\)</span>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Safe Rank</em></p>
<ul class="simple">
<li><p>The Poisson kernel is always half-rank, meaning its rank is equal to half of its size along any of its         dimensions.</p></li>
<li><p>We extensively use a <em>safe rank</em> to protect the user from asking for invalid desired ranks in 2D. A <em>safe rank</em>         is the minimum of the Poisson kernel actual maximum possible rank and the desired rank input by the user. The         main function to do this is <a class="reference internal" href="#src.functions.decompositions.rank_safety_clamp_2d" title="src.functions.decompositions.rank_safety_clamp_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">rank_safety_clamp_2d()</span></code></a> in 2D. There is no need for a rank clamp in 3D because         of how CP decomposition works.</p></li>
<li><p>In our functions ‘safe’ simply means the number of ranked filters we would like to include in our convolutions,         and use it to help with setting up loops etc.</p></li>
<li><p>While in 2D <em>safe</em> means a rank that does not exceed the actual rank of the kernel, in 3D it is different.         Due to the lack of a clear definition of rank in tensor decomposition, we can pretty much ask for any rank in         the CP-vew eigen decomposition and always get something that “<em>works</em>”. This vagueness of a proper rank definition         in 3D is fundamental, which partially contributes to the fact that tensor decomposition is NP-hard.</p></li>
</ul>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.absorb_cores_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">absorb_cores_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cores</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.absorb_cores_3d" title="Permalink to this definition"></a></dt>
<dd><p>Absorb the core weights (eigenvalues) into filters (eigenvectors). Scale each filter by the cubic root of
the corresponding core weight to get the Poisson filters.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p>The absorption of eigenvalues only works when doing the tensor decomposition using <em>Symmetric CP</em>.</p></li>
<li><p>Without this step we do not really have Poisson filters, only eigenvectors.</p></li>
<li><p>This is based on (filter, rank) order, which is the opposite of 2D filter order.</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Symmetric-CP</em> decomposition of 3D Poisson kernel gives a set of factors and cores, where cores can         be taken as the best approximation of true tensor eigenvalues (this should always be taken with a grain of          salt for tensor eigen decomposition as there is no consensus on rank definition in 3D and the tensor eigen         decomposition is <em>NP-hard</em>). To absorb the eigenvalues in filters, we scale each of the three         ranked filters by <span class="math notranslate nohighlight">\(\sqrt[3]{\sigma_{r}}\)</span>, the eigenvalue corresponding to rank <span class="math notranslate nohighlight">\(r\)</span>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cores</strong> (<em>ndarray</em>) – eigenvalues</p></li>
<li><p><strong>factors</strong> (<em>ndarray</em>) – eigenv ectors</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>3D Poisson filters</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.compute_low_rank_kernel_from_filters_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">compute_low_rank_kernel_from_filters_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_rank</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.compute_low_rank_kernel_from_filters_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute a low rank kernel from the given Poisson filters. Filters can be in the original form or
can be truncated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hor</strong> (<em>ndarray</em>) – 2d array: horizontal filters as 2-tuple (rank, filter)</p></li>
<li><p><strong>ver</strong> (<em>ndarray</em>) – 2d array: vertical filters as 2-tuple (rank, filter)</p></li>
<li><p><strong>safe_rank</strong> (<em>int</em>) – cumulative rank, i.e. maximum rank to be included. must be safe.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>square low rank kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.compute_nth_kernel_mode_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">compute_nth_kernel_mode_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.compute_nth_kernel_mode_2d" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct the rank-1 matrix corresponding to the <span class="math notranslate nohighlight">\(r\)</span> -th rank (mode) from horizontal and vertical
Poisson filters for a desired rank.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Singular values must be already absorbed into the filters.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hor</strong> (<em>ndarray</em>) – 2d array: horizontal filters as 2-tuple (rank, filter)</p></li>
<li><p><strong>ver</strong> (<em>ndarray</em>) – 2d array: vertical filters as 2-tuple (rank, filter)</p></li>
<li><p><strong>rank</strong> (<em>int</em>) – desired safe rank. rank needs to be equal or less than the original decomposed matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(r\)</span> -th mode square matrix constructed from the <span class="math notranslate nohighlight">\(r\)</span> -th pair of filters</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.compute_nth_kernel_mode_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">compute_nth_kernel_mode_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ranked_filter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.compute_nth_kernel_mode_3d" title="Permalink to this definition"></a></dt>
<dd><p>Reconstruct the rank-1 tensor corresponding to the <span class="math notranslate nohighlight">\(r\)</span> -th rank (mode) from the Poisson filter of a     certain rank.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All 3 dimensions use the same filter.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Core values (eigenvalues) must be already absorbed into the filters.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ranked_filter</strong> (<em>ndarray</em>) – single Poisson filter, 1d array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(r\)</span> -th mode tensor constructed from the <span class="math notranslate nohighlight">\(r\)</span> -th ranked filter</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.compute_separable_filters_trunc_adaptive_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">compute_separable_filters_trunc_adaptive_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">VT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trunc_threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.compute_separable_filters_trunc_adaptive_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Poisson filters from <em>SVD</em> components and truncate them based on a fixed cut-off threshold.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It does not guarantee the returned filters have the same size due to adaptive truncation
unless <code class="code docutils literal notranslate"><span class="pre">preserve_shape=True</span></code> (Default).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>VT</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{V^T}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>rank</strong> (<em>int</em>) – desired rank. It will be safely clamp if larger than the input matrix actual rank.</p></li>
<li><p><strong>trunc_threshold</strong> – truncation threshold (absolute value)</p></li>
<li><p><strong>preserve_shape</strong> – if <code class="code docutils literal notranslate"><span class="pre">True</span></code> keep the original shape and fill them with zeros (Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>stacked array of truncated horizontal and vertical separable filters for <span class="math notranslate nohighlight">\(n\)</span> ranks, in the form of
a 2-tuple (rank, 1d filter). The clamped safe rank is also returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.compute_separable_filters_trunc_percent_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">compute_separable_filters_trunc_percent_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">VT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trunc_factor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.compute_separable_filters_trunc_percent_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Poisson filters from <em>SVD</em> components and truncate a certain percentage of them.</p>
<p>Since filters are symmetrical, the truncation is applied to both sides of the filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>VT</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{V^T}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>rank</strong> (<em>int</em>) – desired rank. It will be safely clamp if larger than the input matrix actual rank.</p></li>
<li><p><strong>trunc_factor</strong> (<em>float</em>) – truncation percentage in [0, 1]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>stacked array of truncated horizontal and vertical separable filters for <span class="math notranslate nohighlight">\(n\)</span> ranks, in the form of
a 2-tuple (rank, 1d filter). The clamped safe rank is also returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.compute_separable_filters_truncated_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">compute_separable_filters_truncated_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">VT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trunc_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trunc_factor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.compute_separable_filters_truncated_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute and truncate 2D Poisson filters.</p>
<p>Truncation is either based on cutting off a certain percentage of the filter, or using a fixed cut-off     threshold (<em>adaptive truncation</em>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>VT</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{V^T}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>rank</strong> (<em>int</em>) – desired rank. Does not have to be a safe rank</p></li>
<li><p><strong>trunc_method</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.TruncationMode" title="src.helper.commons.TruncationMode"><em>TruncationMode</em></a>) – either <code class="code docutils literal notranslate"><span class="pre">PERCENTAGE</span></code> or <code class="code docutils literal notranslate"><span class="pre">FIXED_THRESHOLD</span></code></p></li>
<li><p><strong>trunc_factor</strong> (<em>float</em>) – percentage in [0, 1] if <code class="code docutils literal notranslate"><span class="pre">PERCENTAGE</span></code>,
fixed cut-off threshold if <code class="code docutils literal notranslate"><span class="pre">FIXED_THRESHOLD</span></code></p></li>
<li><p><strong>preserve_shape</strong> (<em>bool</em>) – if <code class="code docutils literal notranslate"><span class="pre">True</span></code> keep the original shape and fill them with zeros,
else return the shrunk filter</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>stacked array of truncated horizontal and vertical separable filters for <span class="math notranslate nohighlight">\(n\)</span> ranks, in the form of
a 2-tuple (rank, 1d filter). The clamped safe rank is also returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.demo_test_svd_absorb">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">demo_test_svd_absorb</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.demo_test_svd_absorb" title="Permalink to this definition"></a></dt>
<dd><p><em>Sanity check</em>: Testing the eigenvalue absorption into the separable filters in 2D.</p>
<p>We expect the low-rank matrix obtained from the reduced     space exactly matching the reconstruction from the outer product of horizontal and vertical filters. Here by     <em>“matching exactly”</em> we mean machine precision.</p>
<p>Because the Poisson kernel is always square with non-negative eigenvalues, the singular values     obtained from SVD coincide with the eigenvalues. This is not true in general, and is only true in our case     given the special properties of the Poisson kernel, like symmetry.</p>
<p>To absorb the eigenvalues in filters, we scale each of the two ranked filters by     <span class="math notranslate nohighlight">\(\sqrt{\sigma_{r}}\)</span>, the eigenvalue corresponding to rank <span class="math notranslate nohighlight">\(r\)</span>.</p>
<p>See <a class="reference internal" href="#src.functions.decompositions.get_filters_from_svd_components_2d" title="src.functions.decompositions.get_filters_from_svd_components_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_filters_from_svd_components_2d()</span></code></a> for more details.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.get_filters_from_svd_components_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">get_filters_from_svd_components_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">VT</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.get_filters_from_svd_components_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute separable Poisson filters using the <em>Canonical Polyadic (CP)</em> view of the kernel matrix.</p>
<p>We do not need to explicitly perform <em>Canonical Polyadic Decomposition (CPD)</em> in 2D. Instead, we can decompose
the matrix into a summation of rank-1 matrices (as CPD does) by manipulating the components obtained from
<em>Singular Value Decomposition (SVD)</em> of
the same matrix. This involves reconstructing each rank-1 matrix by multiplying columns of <span class="math notranslate nohighlight">\(U\)</span> and rows of
<span class="math notranslate nohighlight">\(V^T\)</span> scaled by the squared root of the corresponding singular value.</p>
<p>Given the <em>SVD</em> of a square kernel <span class="math notranslate nohighlight">\(\mathbf{F}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathbf{F} \approx \mathbf{USV^T}\]</div>
<dl class="simple">
<dt>where:</dt><dd><ul class="simple">
<li><p>The columns of <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> are the left-singular vectors of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span></p></li>
<li><p>The columns of <span class="math notranslate nohighlight">\(\mathbf{V}\)</span> are the right-singular vectors of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span></p></li>
<li><p>The values along the diagonal of <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> are the singular values of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span></p></li>
</ul>
</dd>
</dl>
<p>The <em>CP</em> view is obtained by</p>
<div class="math notranslate nohighlight">
\[\mathbf{F} \approx \displaystyle\sum_{j=1}^n s_j \mathbf{u}_j \otimes \mathbf{v}_j\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{u}_j\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}_j\)</span> are the <span class="math notranslate nohighlight">\(j\)</span> -th columns of the left- and right-singular
vectors, <span class="math notranslate nohighlight">\(s_j\)</span> is the <span class="math notranslate nohighlight">\(j\)</span> -th singular value, and <span class="math notranslate nohighlight">\(\otimes\)</span> is the outer product.
The summation gives <span class="math notranslate nohighlight">\(n\)</span> rank-1 matrices, each of which meets the rank-1 separability condition to
compute our filters, where <span class="math notranslate nohighlight">\(n\)</span> can be the maximum rank of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> or less.</p>
<p>With the above formulation the <span class="math notranslate nohighlight">\(j\)</span> -th component corresponds to the <span class="math notranslate nohighlight">\(r\)</span> -th rank in the <em>CP</em> view.
This means the <span class="math notranslate nohighlight">\(\mathbf{u}_j\)</span> and <span class="math notranslate nohighlight">\(\mathbf{v}_j\)</span> can be taken as the separable filters needed to
reconstruct the <span class="math notranslate nohighlight">\(r\)</span> -th mode <span class="math notranslate nohighlight">\(\mathbf{F}_r\)</span>, scaled by its singular value <span class="math notranslate nohighlight">\(s_r\)</span> (which is the same as its eigenvalue, as explained in the next section)</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{F_r} = s_r (\mathbf{u_r} \otimes \mathbf{v_r})=s_r \left[\begin{array}{c}
u_{r_1} \\
u_{r_2} \\
\vdots \\
u_{r_n}
\end{array}\right] \otimes \left[\begin{array}{c}
v_{r_1} \\
v_{r_2} \\
\vdots \\
v_{r_n}
\end{array}\right] = s_r \left[\begin{array}{cccc}
u_{r_1} v_{r_1} &amp; u_{r_1} v_{r_2} &amp; \cdots &amp; u_{r_1} v_{r_n} \\
u_{r_2} v_{r_1} &amp; u_{r_2} v_{r_2} &amp; \cdots &amp; u_{r_2} v_{r_n} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
u_{r_n} v_{r_1} &amp; u_{r_n} v_{r_2} &amp; \cdots &amp; u_{r_n} v_{r_n}
\end{array}\right]\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{F_r}\)</span> is the <span class="math notranslate nohighlight">\(r\)</span> -th rank-1 square matrix component of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> in
the <em>CP</em> view. As the final step to get the Poisson filters we need to absorb the singular values into the filters.</p>
<p><strong>Absorbing singular values into separable filters</strong></p>
<p>Because the Poisson kernel is always square with non-negative eigenvalues, the singular values obtained from <em>SVD</em> coincide with the eigenvalues. This is not true in general, and is only true in our case given the aforementioned properties of the kernel. To absorb the eigenvalues in filters, we scale each of the two ranked filters by <span class="math notranslate nohighlight">\(\sqrt{\sigma_{r}}\)</span>, where <span class="math notranslate nohighlight">\(\sigma_r = s_j = s_r\)</span>, the <span class="math notranslate nohighlight">\(r\)</span> -th singular value.</p>
<p>The <span class="math notranslate nohighlight">\(r\)</span> -th vertical <span class="math notranslate nohighlight">\(f_v\)</span> and horizontal <span class="math notranslate nohighlight">\(f_h\)</span> Poisson filters reconstructing the <span class="math notranslate nohighlight">\(r\)</span> -th mode are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{f_{v_r}}=\sqrt{\sigma_{r}} \left[\begin{array}{c}
u_{r_1} \\
u_{r_2} \\
\vdots \\
u_{r_n}
\end{array}\right], \; \; \; \mathbf{f_{h_r}}=\sqrt{\sigma_{r}} \left[\begin{array}{c}
v_{r_1} \\
v_{r_2} \\
\vdots \\
v_{r_n}
\end{array}\right]\end{split}\]</div>
<p>which are then used to compute <span class="math notranslate nohighlight">\(\mathbf{F_r} = \mathbf{f_{v_r}} \otimes \mathbf{f_{h_r}}\)</span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In theory, the horizontal and vertical Poisson filters are the same due to the symmetry in the full Poisson kernel. However, and in practice, <em>SVD</em> might give singular vectors with opposing signs.
To avoid any problem, we save and apply each of the filters separately.</p>
<p>This is not a problem in 3D because of the way <em>Sym-CP</em> does the decomposition.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rank</strong> (<em>int</em>) – desired rank. Does not have to be a safe rank</p></li>
<li><p><strong>U</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
<li><p><strong>VT</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(\mathbf{V^T}\)</span> in <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>horizontal and vertical Poisson filters</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.get_max_rank_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">get_max_rank_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.get_max_rank_2d" title="Permalink to this definition"></a></dt>
<dd><p>Get the maximum possible rank of a Poisson kernel with the given target Jacobi iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration</p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – if we are zero-initializing the Jacobi solution, in which case the corresponding Poisson
kernel will have a smaller size. Typical value is <code class="code docutils literal notranslate"><span class="pre">True</span></code> because we usually start from <span class="math notranslate nohighlight">\(x=0\)</span>,
i.e. no warm starting.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>maximum possible rank</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.poisson_components_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">poisson_components_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.poisson_components_2d" title="Permalink to this definition"></a></dt>
<dd><p>Generate 2d Poisson kernel and decompose it using <em>SVD</em> to get <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To set rank, order, and other relevant parameters you need to pack <code class="code docutils literal notranslate"><span class="pre">OptionsKernel</span></code> and
<code class="code docutils literal notranslate"><span class="pre">OptionsReduction</span></code> in <code class="code docutils literal notranslate"><span class="pre">OptionsGeneral</span></code> and send it to this function.         These dataclasses are in <code class="code docutils literal notranslate"><span class="pre">helper.commons.py</span></code>.
To see how to pack options, look at main demos, or see <code class="xref py py-func docutils literal notranslate"><span class="pre">helper.commons.generic_options()</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – parameters bundle</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\mathbf{U}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{V^T}\)</span> components,         as well as the low rank kernel with the same size as the input with the desired rank</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.poisson_compute_modes_trim_filters_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">poisson_compute_modes_trim_filters_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank_filter_reorder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_trim_zeros</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.poisson_compute_modes_trim_filters_3d" title="Permalink to this definition"></a></dt>
<dd><p>Compute 3D ranked modes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – parameters bundle</p></li>
<li><p><strong>rank_filter_reorder</strong> (<em>bool</em>) – if <code class="code docutils literal notranslate"><span class="pre">True</span></code> change 2-tuple order from default (filters, ranks) to
(ranks, filters), which is more consistent with 2D filters. Typical value is <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>filter_trim_zeros</strong> (<em>bool</em>) – if <code class="code docutils literal notranslate"><span class="pre">True</span></code> do not preserve shape, cut the zeros on each side of the filter         (Default= <code class="code docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><strong>preserve_shape</strong> (<em>bool</em>) – if <code class="code docutils literal notranslate"><span class="pre">True</span></code> keep the original shape and fill them with zeros,
else return the shrunk filter (Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>3D ranked modes, Poisson filters, a low rank reconstructed kernel along with the full kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.poisson_decomposition_components_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">poisson_decomposition_components_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.poisson_decomposition_components_3d" title="Permalink to this definition"></a></dt>
<dd><p>Compute 3D cores, factors, low rank kernel and full kernel.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use <em>Symmetric CP</em> as the main decomposition method. <em>Tucker</em> decomposition is also available         for experimentation.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – parameters bundle</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>reduced low rank kernel, cores and factors after decomposition, as well as the full (i.e. unreduced) kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.poisson_filters_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">poisson_filters_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.poisson_filters_2d" title="Permalink to this definition"></a></dt>
<dd><p>Generate 2D Poisson filters.</p>
<p>First generate the kernel then compute the filters using singular value decomposition (<em>SVD</em>).
Check out <a class="reference internal" href="#src.functions.decompositions.get_filters_from_svd_components_2d" title="src.functions.decompositions.get_filters_from_svd_components_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_filters_from_svd_components_2d()</span></code></a> to see how we do filter computation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To set rank, order, and other relevant parameters you need to pack <code class="code docutils literal notranslate"><span class="pre">OptionsKernel</span></code> and
<code class="code docutils literal notranslate"><span class="pre">OptionsReduction</span></code> in <code class="code docutils literal notranslate"><span class="pre">OptionsGeneral</span></code> and send it to this function.         These dataclasses are in <code class="code docutils literal notranslate"><span class="pre">helper.commons.py</span></code>.
To see how to pack options, look at main demos, or see <code class="xref py py-func docutils literal notranslate"><span class="pre">helper.commons.generic_options()</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – parameters bundle</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>horizontal and vertical filters</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.poisson_filters_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">poisson_filters_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank_filter_reorder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.poisson_filters_3d" title="Permalink to this definition"></a></dt>
<dd><p>Generate 3D Poisson filters (with truncation if desired).</p>
<p>First generate the kernel then compute the filters using Eigenvalue Decomposition of a 3D kernel tensor.
See <a class="reference internal" href="#src.functions.decompositions.poisson_decomposition_components_3d" title="src.functions.decompositions.poisson_decomposition_components_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_decomposition_components_3d()</span></code></a> for decomposition methods.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Check out <a class="reference internal" href="#src.functions.decompositions.get_filters_from_svd_components_2d" title="src.functions.decompositions.get_filters_from_svd_components_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_filters_from_svd_components_2d()</span></code></a> to learn about the basics of Poisson filter         computation in 2D.
For 3D filters apply the same principles except for an extra filter in 3D dimension. The outer product
<span class="math notranslate nohighlight">\(\otimes\)</span> in 2D becomes tensor product in 3D.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To set rank, order, and other relevant parameters you need to pack <code class="code docutils literal notranslate"><span class="pre">OptionsKernel</span></code> and
<code class="code docutils literal notranslate"><span class="pre">OptionsReduction</span></code> in <code class="code docutils literal notranslate"><span class="pre">OptionsGeneral</span></code> and send it to this function.         These dataclasses are in <code class="code docutils literal notranslate"><span class="pre">helper.commons.py</span></code>.
To see how to pack options, look at main demos, or see <code class="xref py py-func docutils literal notranslate"><span class="pre">helper.commons.generic_options()</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – parameters bundle</p></li>
<li><p><strong>rank_filter_reorder</strong> (<em>bool</em>) – if <code class="code docutils literal notranslate"><span class="pre">True</span></code> change 2-tuple order from default (filters, ranks) to
(ranks, filters), which is more consistent with 2D filters. Typical value is <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>preserve_shape</strong> – if <code class="code docutils literal notranslate"><span class="pre">True</span></code> keep the original shape and fill them with zeros,
else return the shrunk filter (Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>3 Poisson filters for horizontal, vertical and depth (fiber) passes. The filters can be already truncated if             truncation parameters are set in <code class="code docutils literal notranslate"><span class="pre">opts</span></code></p></li>
<li><p>generated Poisson kernel tensor</p></li>
<li><p>reduced (low rank) reconstructed Poisson kernel corresponding to the desired rank specified in <code class="code docutils literal notranslate"><span class="pre">opts</span></code></p></li>
<li><p>safe rank</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.poisson_svd_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">poisson_svd_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.poisson_svd_2d" title="Permalink to this definition"></a></dt>
<dd><p><em>Singular value decomposition (SVD)</em> of the 2D Poisson kernel.</p>
<p>Decompose, reduce and reconstruct a low rank kernel by truncating the singular values based on the given     desired rank.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Useful links</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.analyticsvidhya.com/blog/2019/08/5-applications-singular-value-decomposition-svd-data-science/">Simple reduction</a></p></li>
<li><p><a class="reference external" href="https://towardsdatascience.com/pca-and-svd-explained-with-numpy-5d13b0d2a4d8">PCA and SVD</a></p></li>
<li><p><a class="reference external" href="https://hadrienj.github.io/posts/Deep-Learning-Book-Series-2.8-Singular-Value-Decomposition/">Intuition</a></p></li>
<li><p><a class="reference external" href="https://machinelearningmastery.com/singular-value-decomposition-for-machine-learning/">Truncated SVD using sklearn</a></p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P</strong> (<em>ndarray</em>) – input Poisson kernel matrix</p></li>
<li><p><strong>rank</strong> (<em>int</em>) – desired rank. Must be a safe rank, i.e. the minimum of the Poisson kernel actual maximum possible         rank and the desired rank input by the user. See <strong>notes</strong> and <a class="reference internal" href="#src.functions.decompositions.rank_safety_clamp_2d" title="src.functions.decompositions.rank_safety_clamp_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">rank_safety_clamp_2d()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\mathbf{U}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{S}\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{V^T}\)</span> components in         <code class="code docutils literal notranslate"><span class="pre">svd(P)</span></code> = <span class="math notranslate nohighlight">\(\mathbf{USV^T}\)</span>, as well as         the low rank kernel with the same size as the input and reduced to have maximum a rank as the         desired input rank.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.poisson_symcp_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">poisson_symcp_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.poisson_symcp_3d" title="Permalink to this definition"></a></dt>
<dd><p>Decompose a full 3D Poisson kernel using symmetric CP (Canonical Polyadic) decomposition.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For a kernel of shape (1, 1, 1) corresponding to a target iteration of 1, Sym-CP does not work.         To avoid bugs or crashes, we return a set of zero <span class="math notranslate nohighlight">\(1 \times 1\)</span> vectors (as many as target rank),         with the first factor being the only non-zero vector and with the value equal to the only scalar value we have         from the (1, 1, 1) kernel. Cores will be all ones. The reduced kernel will be the same as the original full         kernel (there is no reduction).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rank</strong> (<em>int</em>) – target decomposition rank</p></li>
<li><p><strong>kernel</strong> (<em>ndarray</em>) – full 3D Poisson kernel</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>reduced (lowe rank) kernel and decomposition cores and factors</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.poisson_tucker_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">poisson_tucker_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.poisson_tucker_3d" title="Permalink to this definition"></a></dt>
<dd><p>Decompose a full 3D Poisson functions using tensor Tucker decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rank</strong> (<em>int</em>) – target decomposition rank</p></li>
<li><p><strong>kernel</strong> (<em>ndarray</em>) – full 3D Poisson kernel</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>reduced (lowe rank) kernel and decomposition cores and factors</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.decompositions.rank_safety_clamp_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.decompositions.</span></span><span class="sig-name descname"><span class="pre">rank_safety_clamp_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.decompositions.rank_safety_clamp_2d" title="Permalink to this definition"></a></dt>
<dd><p>Clamp the given desired rank based on the maximum possible rank of a
Poisson kernel with the given target Jacobi iteration.</p>
<p>The Poisson kernel is always half-rank, meaning its rank is equal to half of its size along any of its dimensions.
A safe rank is the minimum of the Poisson kernel actual maximum possible rank and the desired rank.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration</p></li>
<li><p><strong>rank</strong> (<em>int</em>) – desired rank</p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – if we are zero-initializing the Jacobi solution, in which case the corresponding Poisson
kernel will have a smaller size. Typical value is <code class="code docutils literal notranslate"><span class="pre">True</span></code> because we usually start from <span class="math notranslate nohighlight">\(x=0\)</span>,
i.e. no warm starting.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>safe rank</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="module-src.functions.generator">
<span id="src-functions-generator-module"></span><h2>src.functions.generator module<a class="headerlink" href="#module-src.functions.generator" title="Permalink to this heading"></a></h2>
<dl class="field-list simple">
<dt class="field-odd">author</dt>
<dd class="field-odd"><p>Shahin (Amir Hossein) Rabbani</p>
</dd>
<dt class="field-even">contact</dt>
<dd class="field-even"><p><a class="reference external" href="mailto:shahin&#46;rab&#37;&#52;&#48;gmail&#46;com">shahin<span>&#46;</span>rab<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt class="field-odd">copyright</dt>
<dd class="field-odd"><p>See <a class="reference internal" href="license.html#license-page"><span class="std std-ref">License</span></a></p>
</dd>
</dl>
<section id="generator-method">
<span id="id1"></span><h3>Technicals<a class="headerlink" href="#generator-method" title="Permalink to this heading"></a></h3>
<p>We use a recursive function to generate the Poisson kernel. Due to similarities between sub-problems, we enhance     the recursion performance by <em>memoization</em>, i.e. saving the solution and reusing it multiple times.     See <a class="reference internal" href="#src.functions.generator.poisson_kernel_2d" title="src.functions.generator.poisson_kernel_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_2d()</span></code></a> and <a class="reference internal" href="#src.functions.generator.poisson_kernel_3d" title="src.functions.generator.poisson_kernel_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_3d()</span></code></a>.</p>
<p class="rubric">Notes</p>
<p>Choosing the kernel type <code class="code docutils literal notranslate"><span class="pre">UNIFIED</span></code> vs <code class="code docutils literal notranslate"><span class="pre">STANDARD</span></code>:</p>
<blockquote>
<div><dl>
<dt>UNIFIED</dt><dd><p>The <code class="code docutils literal notranslate"><span class="pre">UNIFIED</span></code> type produces the exact same parametric kernel for both <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code> and <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code>
Poisson equations. While for the <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code> version the kernel already supports warm starting,
for the <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code>  version it only works with a zero initial guess. Also, we will need to negate
the input to make it work for <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code> applications.</p>
<ul class="simple">
<li><p><em>Upside</em>: Same kernel generator for both <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code>  and <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code>. No pre-assumption about                 the type of the Poisson equation we are solving.</p></li>
<li><p><em>Downside</em>: for <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code> Poisson (e.g. poisson pressure) you would need to negate the input                 divergence before feeding it to the solver.</p></li>
</ul>
</dd>
<dt>STANDARD (<em>Safer</em>)</dt><dd><p>The <code class="code docutils literal notranslate"><span class="pre">STANDARD</span></code> type has an alternating sign for <span class="math notranslate nohighlight">\(\alpha\)</span> in the parametric kernel,             so the two kernels
for <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code> and <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code>  are not exactly the same, but it supports warm starting for both             <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code> and particularly <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code>. An example of warm starting is when if you want             to initialize the first guess of the pressure in Poisson-pressure solve from <em>RHS</em> (divergence).</p>
<ul class="simple">
<li><p><em>Upside</em>: Supports warm starting (but within the constraints of Poisson filters applications -             see paper). Less confusion in applying filters and convergence analysis.</p></li>
<li><p><em>Downside</em>: Needs a separate call to each <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code> and <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code> Poisson kernel generators,             which is not a major inconvenience.</p></li>
</ul>
<p><code class="code docutils literal notranslate"><span class="pre">STANDARD</span></code> is the recommended default type.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Application Notes:</dt><dd><ul class="simple">
<li><p>In addition to the target Jacobi iteration, <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are the two major players         when generating the Poisson kernel. Things like the unit cell size <span class="math notranslate nohighlight">\(dx\)</span>, time step <span class="math notranslate nohighlight">\(dt\)</span> and         diffusivity factor <span class="math notranslate nohighlight">\(\kappa\)</span> (where <span class="math notranslate nohighlight">\(dt\)</span> and <span class="math notranslate nohighlight">\(\kappa\)</span> are only used by the <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code>         Poisson kernel), are captured by <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span>.         Check out <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a> and <a class="reference internal" href="#src.functions.generator.compute_beta" title="src.functions.generator.compute_beta"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_beta()</span></code></a> to see how they are set.         In practice, you would only need to provide         <span class="math notranslate nohighlight">\(dx\)</span>, <span class="math notranslate nohighlight">\(dt\)</span> and <span class="math notranslate nohighlight">\(\kappa\)</span>, and the generator automatically computes <span class="math notranslate nohighlight">\(\alpha\)</span>         and <span class="math notranslate nohighlight">\(\beta\)</span> based on  the problem dimension and the Poisson equation type.</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> has a negative sign in the original Jacobi equation for pressure. To make         the kernel generation consistent for both <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code> and <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code> we treat <span class="math notranslate nohighlight">\(\alpha\)</span>         as positive for both cases. So for example to solve Poisson-pressure (inverse Poisson) you should multiply         the <em>rhs</em> divergence by <span class="math notranslate nohighlight">\(-1\)</span> to account for the sign change.</p></li>
<li><p><strong>Warm starting</strong>: often found as <code class="code docutils literal notranslate"><span class="pre">zero_init</span></code> parameter in some functions, Poisson filters have limited         support for warm starting the linear solve (as discussed in the paper). See <a class="reference internal" href="#src.functions.generator.i_want_to_warm_start" title="src.functions.generator.i_want_to_warm_start"><code class="xref py py-func docutils literal notranslate"><span class="pre">i_want_to_warm_start()</span></code></a> and         <a class="reference internal" href="#src.functions.generator.is_ok_to_zero_init" title="src.functions.generator.is_ok_to_zero_init"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_ok_to_zero_init()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you decide to change/improve things:</p>
<ul class="simple">
<li><p>You can generate Poisson kernels with <span class="math notranslate nohighlight">\(\alpha=1\)</span> then just scale <span class="math notranslate nohighlight">\(B\)</span> in <span class="math notranslate nohighlight">\(L*X = B\)</span>         (the input matrix) with the actual <span class="math notranslate nohighlight">\(\alpha\)</span> you are interested in.         This means if doing only <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code> you can factorize <span class="math notranslate nohighlight">\(\alpha\)</span> from the kernel generation and change it in         real time in your application (multiplying filter convolution results by <span class="math notranslate nohighlight">\(\alpha\)</span>).         However, in the <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code> case, and due to the presence of <span class="math notranslate nohighlight">\(\alpha\)</span> in the way <span class="math notranslate nohighlight">\(\beta\)</span>         is computed, we can’t do this factorization.</p></li>
<li><p>In the current implementation, we decided to explicitly include         <span class="math notranslate nohighlight">\(\alpha\)</span> in the kernel to have a uniform formulation that works for both <code class="code docutils literal notranslate"><span class="pre">FORWARD</span></code>         and <code class="code docutils literal notranslate"><span class="pre">INVERSE</span></code>.</p></li>
</ul>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.compute_alpha">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">compute_alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.compute_alpha" title="Permalink to this definition"></a></dt>
<dd><p>Compute <span class="math notranslate nohighlight">\(\alpha\)</span> that is used in kernel generation, for both 2D and 3D (see <a class="reference internal" href="#src.functions.generator.poisson_kernel_2d" title="src.functions.generator.poisson_kernel_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_2d()</span></code></a>     and <a class="reference internal" href="#src.functions.generator.poisson_kernel_3d" title="src.functions.generator.poisson_kernel_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_3d()</span></code></a> for application).</p>
<dl class="simple">
<dt>In forward and inverse Poisson equations we have different equations:</dt><dd><ul class="simple">
<li><p><em>Forward</em>: <span class="math notranslate nohighlight">\(\alpha = +{(dx)}^2/{(\kappa . dt)}\)</span></p></li>
<li><p><em>Inverse</em>: <span class="math notranslate nohighlight">\(\alpha = -{(dx)}^2\)</span></p></li>
</ul>
</dd>
<dt>where:</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(dx:\)</span> cell size</p></li>
<li><p><span class="math notranslate nohighlight">\(dt:\)</span> time step (if <em>forward</em> Poisson is intended)</p></li>
<li><p><span class="math notranslate nohighlight">\(\kappa\)</span>: diffusivity (if <em>forward</em> Poisson is intended)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dx</strong> (<em>float</em>) – cell size</p></li>
<li><p><strong>dt</strong> (<em>float</em>) – time step</p></li>
<li><p><strong>kappa</strong> (<em>float</em>) – diffusivity</p></li>
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse or forward</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\alpha\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.compute_beta">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">compute_beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.compute_beta" title="Permalink to this definition"></a></dt>
<dd><p>Compute <span class="math notranslate nohighlight">\(\beta\)</span> that is used in kernel generation, for both 2D and 3D (see <a class="reference internal" href="#src.functions.generator.poisson_kernel_2d" title="src.functions.generator.poisson_kernel_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_2d()</span></code></a>     and <a class="reference internal" href="#src.functions.generator.poisson_kernel_3d" title="src.functions.generator.poisson_kernel_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_3d()</span></code></a> for application).</p>
<dl class="simple">
<dt><span class="math notranslate nohighlight">\(\beta\)</span> values based on dimension and Poisson solver type:</dt><dd><ul class="simple">
<li><p>2D <em>Inverse</em>: <span class="math notranslate nohighlight">\(\beta = 4\)</span></p></li>
<li><p>2D <em>Forward</em>: <span class="math notranslate nohighlight">\(\beta = 4 + \alpha\)</span></p></li>
<li><p>3D <em>Inverse</em>: <span class="math notranslate nohighlight">\(\beta = 6\)</span></p></li>
<li><p>3D <em>Forward</em>: <span class="math notranslate nohighlight">\(\beta = 6 + \alpha\)</span></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em>) – see <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a></p></li>
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse or forward</p></li>
<li><p><strong>dim</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.SolverDimension" title="src.helper.commons.SolverDimension"><em>SolverDimension</em></a>) – solver dimension, 2D or 3D</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\beta\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.get_alpha_sign">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">get_alpha_sign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.get_alpha_sign" title="Permalink to this definition"></a></dt>
<dd><p>Compute <span class="math notranslate nohighlight">\(\alpha\)</span> sign that is used in kernel generation, for both 2D and 3D (see <a class="reference internal" href="#src.functions.generator.poisson_kernel_2d" title="src.functions.generator.poisson_kernel_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_2d()</span></code></a>     and <a class="reference internal" href="#src.functions.generator.poisson_kernel_3d" title="src.functions.generator.poisson_kernel_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_3d()</span></code></a> for application).</p>
<dl class="simple">
<dt>In forward and inverse Poisson equations we have different equations, and hence different <span class="math notranslate nohighlight">\(\alpha\)</span> signs:</dt><dd><ul class="simple">
<li><p><em>Forward</em>: <span class="math notranslate nohighlight">\(\alpha = +{(dx)}^2/{(\kappa . dt)}\)</span></p></li>
<li><p><em>Inverse</em>: <span class="math notranslate nohighlight">\(\alpha = -{(dx)}^2\)</span></p></li>
</ul>
</dd>
<dt>where:</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(dx:\)</span> cell size</p></li>
<li><p><span class="math notranslate nohighlight">\(dt:\)</span> time step (if <em>forward</em> Poisson is intended)</p></li>
<li><p><span class="math notranslate nohighlight">\(\kappa\)</span>: diffusivity (if <em>forward</em> Poisson is intended)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse or forward</p></li>
<li><p><strong>kernel_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonKernelType" title="src.helper.commons.PoissonKernelType"><em>PoissonKernelType</em></a>) – unified or standard</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sign of alpha</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.get_kernel_size">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">get_kernel_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.get_kernel_size" title="Permalink to this definition"></a></dt>
<dd><p>Get the expected Poisson kernel size along each dimension for a given target Jacobi iteration (<em>order</em>) and    based on whether we want to warm start or not.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>The kernel is always either square (2D matrix) or cube (3D tensor). The kernel actual size for a         given target Jacobi iteration <span class="math notranslate nohighlight">\(i\)</span> is:</dt><dd><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">zero_init=True</span></code> : <span class="math notranslate nohighlight">\({(2*i-1)}^d\)</span></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">zero_init=False</span></code> : <span class="math notranslate nohighlight">\({(2*i+1)}^d\)</span></p></li>
</ul>
</dd>
</dl>
<p>for dimension <span class="math notranslate nohighlight">\(d=2,3\)</span>. This function only returns the base size and not the kernel actual size.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration</p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – see <a class="reference internal" href="#src.functions.generator.is_ok_to_zero_init" title="src.functions.generator.is_ok_to_zero_init"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_ok_to_zero_init()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>kernel size along each dimension</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.get_kernel_size_from_half_size">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">get_kernel_size_from_half_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">half_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.get_kernel_size_from_half_size" title="Permalink to this definition"></a></dt>
<dd><p>Given a half Poisson filter size compute the actual kernel size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>half_size</strong> (<em>int</em>) – half filter size excluding the element in the middle.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>kernel size</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.i_want_to_warm_start">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">i_want_to_warm_start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warm_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.i_want_to_warm_start" title="Permalink to this definition"></a></dt>
<dd><p>Automatically generate parameters for the kernel and solver if we want to warm start the solution     to <span class="math notranslate nohighlight">\(Ax=b\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>If you are doing <em>inverse</em> Poisson and</dt><dd><ul class="simple">
<li><p>want to avoid negating your input matrix <span class="math notranslate nohighlight">\(B\)</span> (in the <em>matrix-form</em> <span class="math notranslate nohighlight">\(LX=B\)</span>), <strong>or</strong></p></li>
<li><p>want to warm start the solution with the input matrix</p></li>
</ul>
</dd>
</dl>
<p>then it is better to use warm start.</p>
</div>
<p>See also <a class="reference internal" href="#src.functions.generator.is_ok_to_zero_init" title="src.functions.generator.is_ok_to_zero_init"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_ok_to_zero_init()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>warm_start</strong> (<em>bool</em>) – boolean, if we want to warm start or not</p></li>
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse or forward</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.is_ok_to_zero_init">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">is_ok_to_zero_init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.is_ok_to_zero_init" title="Permalink to this definition"></a></dt>
<dd><p>Verify if a zero initial guess is possible based on the Poisson solver type.</p>
<p>We can consider a zero initialization of the unknown quantity in the Jacobi solver when computing     the Poisson kernel.
The current method only supports zero initial guess for the inverse Poisson equation (e.g. Poisson pressure).
It is not possible to use the zero initialization for forward Poisson equation (e.g. diffusion).</p>
<ul class="simple">
<li><p><em>Pressure</em>: it is optional to zero start or warm start</p></li>
<li><p><em>Diffusion</em>: it is mandatory to warm start</p></li>
</ul>
<p>See also <a class="reference internal" href="#src.functions.generator.i_want_to_warm_start" title="src.functions.generator.i_want_to_warm_start"><code class="xref py py-func docutils literal notranslate"><span class="pre">i_want_to_warm_start()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse or forward</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>if it is ok to zero start the solution</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 2D Poisson kernel based on recursive Jacobi.</p>
<p>Recursion is used to generate 2D analytical Poisson kernels based on 4 nearest neighbors only.
Precomputing the Jacobi solution to <span class="math notranslate nohighlight">\(Ax=b\)</span> in the <em>matrix-form</em> <span class="math notranslate nohighlight">\(L*X = B\)</span> using the recursion formula     based on the Jacobi update step:</p>
<p><span class="math notranslate nohighlight">\(x_{here} = (x_{left} + x_{right} + x_{down} + x_{up} + \alpha * b_{here}) / \beta\)</span></p>
<p>where <span class="math notranslate nohighlight">\(x_{here}\)</span> and <span class="math notranslate nohighlight">\(b_{here}\)</span> are the elements of <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> matrices that we would     like to update and evaluate, respectively, and <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are set based on the type of     the Poisson equation.     See <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a> and <a class="reference internal" href="#src.functions.generator.compute_beta" title="src.functions.generator.compute_beta"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_beta()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To set the kernel parameters like target iteration (<em>order</em>), <span class="math notranslate nohighlight">\(dx\)</span>, and others, you need to pack
<code class="code docutils literal notranslate"><span class="pre">OptionsKernel</span></code> and <code class="code docutils literal notranslate"><span class="pre">OptionsPoissonSolver</span></code> in <code class="code docutils literal notranslate"><span class="pre">OptionsGeneral</span></code> and send it to this function.         These dataclasses are in <code class="code docutils literal notranslate"><span class="pre">helper.commons.py</span></code>.
To see how to pack options, look at the main demos, or see <code class="xref py py-func docutils literal notranslate"><span class="pre">helper.commons.generic_options()</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – parameters bundle</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Poisson kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_3d" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 3D Poisson kernel based on recursive Jacobi.</p>
<p>Recursion is used to generate 3D analytical Poisson kernels based on 6 nearest neighbors only.
Precomputing the Jacobi solution to <span class="math notranslate nohighlight">\(Ax=b\)</span> in the <em>matrix-form</em> <span class="math notranslate nohighlight">\(L*X = B\)</span> (quantities are tensors)     using the recursion formula based on the Jacobi update step:</p>
<p><span class="math notranslate nohighlight">\(x_{here} = (x_{left} + x_{right} + x_{down} + x_{up} + x_{front} + x_{back} + \alpha * b_{here}) / \beta\)</span></p>
<p>where <span class="math notranslate nohighlight">\(x_{here}\)</span> and <span class="math notranslate nohighlight">\(b_{here}\)</span> are the elements of <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> tensors that we would     like to update and evaluate, respectively, and <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are set based on the type of     the Poisson equation.     See <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a> and <a class="reference internal" href="#src.functions.generator.compute_beta" title="src.functions.generator.compute_beta"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_beta()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To set the kernel parameters like target iteration (<em>order</em>), <span class="math notranslate nohighlight">\(dx\)</span>, and others, you need to pack
<code class="code docutils literal notranslate"><span class="pre">OptionsKernel</span></code> and <code class="code docutils literal notranslate"><span class="pre">OptionsPoissonSolver</span></code> in <code class="code docutils literal notranslate"><span class="pre">OptionsGeneral</span></code> and send it to this function.         These dataclasses are in <code class="code docutils literal notranslate"><span class="pre">helper.commons.py</span></code>.
To see how to pack options, look at the main demos, or see <code class="xref py py-func docutils literal notranslate"><span class="pre">helper.commons.generic_options()</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – parameters bundle</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Poisson kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_standard_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_standard_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clear_memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_standard_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 2D Poisson <em>Standard</em> kernel based on recursive Jacobi.
See <a class="reference internal" href="#src.functions.generator.poisson_kernel_2d" title="src.functions.generator.poisson_kernel_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_2d()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse, forward</p></li>
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration (<em>kernel order</em>)</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – see <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a></p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – zero as the initial guess. If <code class="code docutils literal notranslate"><span class="pre">True</span></code>, we produce a smaller kernel, else
we are warm starting the Jacobi solver with a non-zero matrix, which makes the kernel slightly         larger (+2 along each dimension).
We can use zero initial guess for Poisson pressure only (inverse Poisson).
Diffusion step (forward Poisson) has to warm start with a non-zero initial guess.</p></li>
<li><p><strong>clear_memo</strong> (<em>bool</em>) – better set to be <code class="code docutils literal notranslate"><span class="pre">True</span></code> for recursion to avoid garbage cashing. Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Jacobi Poisson kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_standard_2d_rec_memo">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_standard_2d_rec_memo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_standard_2d_rec_memo" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 2D Poisson <em>Standard</em> kernel based on recursive Jacobi using memoization, i.e. speed-up by     reusing sub-solutions.
See <a class="reference internal" href="#src.functions.generator.poisson_kernel_2d" title="src.functions.generator.poisson_kernel_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_2d()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse, forward</p></li>
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration (<em>kernel order</em>)</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – see <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a></p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – zero as the initial guess. If <code class="code docutils literal notranslate"><span class="pre">True</span></code>, we produce a smaller kernel, else
we are warm starting the Jacobi solver with a non-zero matrix, which makes the kernel slightly         larger (+2 along each dimension).
We can use zero initial guess for Poisson pressure only (inverse Poisson).
Diffusion step (forward Poisson) has to warm start with a non-zero initial guess.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Jacobi Poisson kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_standard_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_standard_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clear_memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_standard_3d" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 3D Poisson <em>Standard</em> kernel based on recursive Jacobi.
See <a class="reference internal" href="#src.functions.generator.poisson_kernel_3d" title="src.functions.generator.poisson_kernel_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_3d()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse, forward</p></li>
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration (<em>kernel order</em>)</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – see <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a></p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – zero as the initial guess. If <code class="code docutils literal notranslate"><span class="pre">True</span></code>, we produce a smaller kernel, else
we are warm starting the Jacobi solver with a non-zero matrix, which makes the kernel slightly         larger (+2 along each dimension).
We can use zero initial guess for Poisson pressure only (inverse Poisson).
Diffusion step (forward Poisson) has to warm start with a non-zero initial guess.</p></li>
<li><p><strong>clear_memo</strong> (<em>bool</em>) – better set to be <code class="code docutils literal notranslate"><span class="pre">True</span></code> for recursion to avoid garbage cashing. Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Jacobi Poisson kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_standard_3d_rec_memo">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_standard_3d_rec_memo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_standard_3d_rec_memo" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 3D Poisson <em>Standard</em> kernel based on recursive Jacobi using memoization, i.e. speed-up by     reusing sub-solutions.
See <a class="reference internal" href="#src.functions.generator.poisson_kernel_3d" title="src.functions.generator.poisson_kernel_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_3d()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse, forward</p></li>
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration (<em>kernel order</em>)</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – see <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a></p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – zero as the initial guess. If <code class="code docutils literal notranslate"><span class="pre">True</span></code>, we produce a smaller kernel, else
we are warm starting the Jacobi solver with a non-zero matrix, which makes the kernel slightly         larger (+2 along each dimension).
We can use zero initial guess for Poisson pressure only (inverse Poisson).
Diffusion step (forward Poisson) has to warm start with a non-zero initial guess.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Jacobi Poisson kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_unified_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_unified_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clear_memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_unified_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 2D Poisson <em>Unified</em> kernel based on recursive Jacobi.
See <a class="reference internal" href="#src.functions.generator.poisson_kernel_2d" title="src.functions.generator.poisson_kernel_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_2d()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse, forward</p></li>
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration (<em>kernel order</em>)</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – see <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a></p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – zero as the initial guess. If <code class="code docutils literal notranslate"><span class="pre">True</span></code>, we produce a smaller kernel, else
we are warm starting the Jacobi solver with a non-zero matrix, which makes the kernel slightly         larger (+2 along each dimension).
We can use zero initial guess for Poisson pressure only (inverse Poisson).
Diffusion step (forward Poisson) has to warm start with a non-zero initial guess.</p></li>
<li><p><strong>clear_memo</strong> (<em>bool</em>) – better set to be <code class="code docutils literal notranslate"><span class="pre">True</span></code> for recursion to avoid garbage cashing. Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Jacobi Poisson kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_unified_2d_rec_memo">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_unified_2d_rec_memo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_unified_2d_rec_memo" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 2D Poisson <em>Unified</em> kernel based on recursive Jacobi, using memoization, i.e. speed-up by     reusing sub-solutions.
See <a class="reference internal" href="#src.functions.generator.poisson_kernel_2d" title="src.functions.generator.poisson_kernel_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_2d()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse, forward</p></li>
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration (<em>kernel order</em>)</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – see <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a></p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – zero as the initial guess. If <code class="code docutils literal notranslate"><span class="pre">True</span></code>, we produce a smaller kernel, else
we are warm starting the Jacobi solver with a non-zero matrix, which makes the kernel slightly         larger (+2 along each dimension).
We can use zero initial guess for Poisson pressure only (inverse Poisson).
Diffusion step (forward Poisson) has to warm start with a non-zero initial guess.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Jacobi Poisson kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_unified_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_unified_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clear_memo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_unified_3d" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 3D Poisson <em>Unified</em> kernel based on recursive Jacobi.
See <a class="reference internal" href="#src.functions.generator.poisson_kernel_3d" title="src.functions.generator.poisson_kernel_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_3d()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse, forward</p></li>
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration (<em>kernel order</em>)</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – see <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a></p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – zero as the initial guess. If <code class="code docutils literal notranslate"><span class="pre">True</span></code>, we produce a smaller kernel, else
we are warm starting the Jacobi solver with a non-zero matrix, which makes the kernel slightly         larger (+2 along each dimension).
We can use zero initial guess for Poisson pressure only (inverse Poisson).
Diffusion step (forward Poisson) has to warm start with a non-zero initial guess.</p></li>
<li><p><strong>clear_memo</strong> (<em>bool</em>) – better set to be <code class="code docutils literal notranslate"><span class="pre">True</span></code> for recursion to avoid garbage cashing. Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Jacobi Poisson kernel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.generator.poisson_kernel_unified_3d_rec_memo">
<span class="sig-prename descclassname"><span class="pre">src.functions.generator.</span></span><span class="sig-name descname"><span class="pre">poisson_kernel_unified_3d_rec_memo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_init</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.generator.poisson_kernel_unified_3d_rec_memo" title="Permalink to this definition"></a></dt>
<dd><p>Compute a 3D Poisson <em>Unified</em> kernel based on recursive Jacobi using memoization, i.e. speed-up by     reusing sub-solutions.
See <a class="reference internal" href="#src.functions.generator.poisson_kernel_3d" title="src.functions.generator.poisson_kernel_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">poisson_kernel_3d()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>solver_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.PoissonSolverType" title="src.helper.commons.PoissonSolverType"><em>PoissonSolverType</em></a>) – inverse, forward</p></li>
<li><p><strong>itr</strong> (<em>int</em>) – target Jacobi iteration (<em>kernel order</em>)</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – see <a class="reference internal" href="#src.functions.generator.compute_alpha" title="src.functions.generator.compute_alpha"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_alpha()</span></code></a></p></li>
<li><p><strong>zero_init</strong> (<em>bool</em>) – zero as the initial guess. If <code class="code docutils literal notranslate"><span class="pre">True</span></code>, we produce a smaller kernel, else
we are warm starting the Jacobi solver with a non-zero matrix, which makes the kernel slightly         larger (+2 along each dimension).
We can use zero initial guess for Poisson pressure only (inverse Poisson).
Diffusion step (forward Poisson) has to warm start with a non-zero initial guess.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>full Jacobi Poisson kernel</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="module-src.functions.mathlib">
<span id="src-functions-mathlib-module"></span><h2>src.functions.mathlib module<a class="headerlink" href="#module-src.functions.mathlib" title="Permalink to this heading"></a></h2>
<dl class="field-list simple">
<dt class="field-odd">author</dt>
<dd class="field-odd"><p>Shahin (Amir Hossein) Rabbani</p>
</dd>
<dt class="field-even">contact</dt>
<dd class="field-even"><p><a class="reference external" href="mailto:shahin&#46;rab&#37;&#52;&#48;gmail&#46;com">shahin<span>&#46;</span>rab<span>&#64;</span>gmail<span>&#46;</span>com</a></p>
</dd>
<dt class="field-odd">copyright</dt>
<dd class="field-odd"><p>See <a class="reference internal" href="license.html#license-page"><span class="std std-ref">License</span></a></p>
</dd>
</dl>
<section id="mathlib-technicals">
<span id="id2"></span><h3>Technicals<a class="headerlink" href="#mathlib-technicals" title="Permalink to this heading"></a></h3>
<p>The Poisson solver has a linear formulation like in the typical <span class="math notranslate nohighlight">\(Ax=b\)</span> but with a difference of replacing
vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(b\)</span> with matrices, and replacing matrix-vector multiplication with a convolution
operator. We use a proper notation with a difference naming convention:</p>
<p><span class="math notranslate nohighlight">\(Ax = b \leftrightarrow L*X = B\)</span></p>
<dl class="simple">
<dt>where:</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(L\)</span>: Laplacian operator</p></li>
<li><p><span class="math notranslate nohighlight">\(*\)</span>: convolution operator</p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span>: given or unknown matrix, depending on the Poisson equation we are solving for.</p></li>
<li><p><span class="math notranslate nohighlight">\(B\)</span>: given or unknown <em>rhs</em> matrix, depending on the Poisson equation we are solving for.</p></li>
</ul>
</dd>
</dl>
<p>LHS and RHS are both in <em>matrix-forms</em>, i.e. all matrices/tensors have the same dimension.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We call <span class="math notranslate nohighlight">\(Ax=b\)</span> the <em>vector-form</em> and <span class="math notranslate nohighlight">\(L*X=B\)</span> the <em>matrix-form</em>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Poisson kernel (and subsequently its separable filters) are computed based on the <em>matrix-form</em>,         so for an infinite domain without any boundary treatment the solution using the Poisson kernel and the         one from the <em>matrix-form</em> must match to the machine precision.</p>
</div>
<p>The linear solver works with two versions of the Poisson equation, namely <em>inverse</em> and <em>forward</em> :</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>Inverse</strong> : An example is Poisson-pressure where <span class="math notranslate nohighlight">\(B\)</span> is the input divergence and <span class="math notranslate nohighlight">\(X\)</span> is         the output pressure.</p></li>
<li><p><strong>Forward</strong> : An example is diffusion where <span class="math notranslate nohighlight">\(X\)</span> is the input density and the output <span class="math notranslate nohighlight">\(B\)</span> is         the diffused quantity.</p></li>
</ul>
</div></blockquote>
<p>Depending on what we are solving for, we have different setups for input/output:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><strong>Inverse Poisson equation</strong> : Given <span class="math notranslate nohighlight">\(M\)</span> as input in <span class="math notranslate nohighlight">\(L*X = M\)</span>, obtain solution <span class="math notranslate nohighlight">\(X\)</span>             by implicitly approximating <span class="math notranslate nohighlight">\(L^{-1}\)</span> in <span class="math notranslate nohighlight">\(X = L^{-1}*M\)</span>.</p></li>
<li><p><strong>Forward Poisson equation</strong> : Given <span class="math notranslate nohighlight">\(M\)</span> as input, obtain the solution <span class="math notranslate nohighlight">\(B\)</span> to the diffusion             equation, i.e. perform <span class="math notranslate nohighlight">\(L*M = B\)</span> , where <span class="math notranslate nohighlight">\(B\)</span> is the output.</p></li>
</ol>
</div></blockquote>
<p>The solution is computed using an ‘implicit’ finite difference method, Just like Jacobi.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note how the input matrix <span class="math notranslate nohighlight">\(M\)</span> changes role in <span class="math notranslate nohighlight">\(L*X=B\)</span> based on the type of the Poisson         equation setup.</p>
</div>
<p>We use multi-rank Poisson filters for a given rank. Given the Poisson equation in the <em>matrix-form</em>
<span class="math notranslate nohighlight">\(L*X=B\)</span>, the Poisson kernel <span class="math notranslate nohighlight">\(L\)</span> (in forward setup) and its inverse <span class="math notranslate nohighlight">\(L^{-1}\)</span> (in inverse setup)
are already baked into the Poisson filters. Just provide the input data matrix and the corresponding
filters matching the formulation setup you are interested in.</p>
<p>In general, we can replace <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(L^{-1}\)</span> with a unified kernel <span class="math notranslate nohighlight">\(F\)</span> that operates on a
data domain matrix (or tensor), and perform Eigen decomposition on <span class="math notranslate nohighlight">\(F\)</span> to get the Poisson filters.</p>
<section id="convolution-order-of-poisson-filters">
<span id="mathlib-convolution-order"></span><h4>Convolution Order of Poisson Filters<a class="headerlink" href="#convolution-order-of-poisson-filters" title="Permalink to this heading"></a></h4>
<p>Poisson filters are used in cascaded convolutions to get the solution.</p>
<p>In 3D, we have</p>
<p><span class="math notranslate nohighlight">\(F * M \approx \displaystyle\sum_{r=1}^n f_{v_r} * (f_{h_r} * (f_{d_r} * M))\)</span></p>
<dl class="simple">
<dt>where</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F\)</span> - Full Poisson kernel (either <span class="math notranslate nohighlight">\(L\)</span> or <span class="math notranslate nohighlight">\(L^{-1}\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(M\)</span> - Input data field</p></li>
<li><p><span class="math notranslate nohighlight">\(f_v\)</span> - Vertical filter</p></li>
<li><p><span class="math notranslate nohighlight">\(f_h\)</span> - Horizontal filter</p></li>
<li><p><span class="math notranslate nohighlight">\(f_d\)</span> - Depth (fiber) filter</p></li>
<li><p>double subscript <span class="math notranslate nohighlight">\(_r\)</span> means the filter corresponding the current rank</p></li>
<li><p><span class="math notranslate nohighlight">\(\displaystyle\sum_{r=1}^n\)</span> is multi-rank summation (i.e. modal solutions)</p></li>
</ul>
</dd>
</dl>
<p>The convolution order goes from the inner
brackets to outer brackets, meaning first we need to convolve <span class="math notranslate nohighlight">\(M\)</span> with the fiber filter, then
convolve the results with the horizontal and vertical filters.</p>
<p>For multi-rank convolution we have separate and independent convolutions passes on <span class="math notranslate nohighlight">\(M\)</span>, then sum up
the results. The summation comes from the Canonical Polyadic Decomposition (<em>CPD</em>) view in our matrix/tensor
decomposition setup (different in 2D and 3D),
which makes it possible to have rank-1 kernel convolutions to get modal solutions taking care of different
frequencies in the data domain.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>DO NOT</strong> feed input data matrix <span class="math notranslate nohighlight">\(M\)</span> in outer bracket convolution.</p>
<p><strong>ALWAYS</strong> use the results of the previous convolution pass to do the next one.</p>
</div>
<p>Also see <a class="reference internal" href="#src.functions.mathlib.solve_poisson_separable_filters_2d" title="src.functions.mathlib.solve_poisson_separable_filters_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_poisson_separable_filters_2d()</span></code></a> and
<a class="reference internal" href="#src.functions.mathlib.solve_poisson_separable_filters_wall_aware_3d" title="src.functions.mathlib.solve_poisson_separable_filters_wall_aware_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_poisson_separable_filters_wall_aware_3d()</span></code></a> for the convolution order in 2D and 3D.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ground truth Jacobi solver we use in our code uses the same <em>matrix-form</em> setup as the Poisson         Filters/Kernel setup. It is a straightforward practice to establish the connection between Jacobi         <em>matrix-form</em> and the more widely known and used version, Jacobi <em>vector-form</em> .</p>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.apply_adaptive_truncation_1d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">apply_adaptive_truncation_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_off</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.apply_adaptive_truncation_1d" title="Permalink to this definition"></a></dt>
<dd><p>Adaptive truncate all ranked filters using a fixed threshold as the cut-off value, assuming symmetrical     filters and values are sorted sideways from largest (center) to smallest (tales).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array_1d</strong> (<em>ndarray</em>) – input filter</p></li>
<li><p><strong>safe_rank</strong> (<em>int</em>) – desired input rank. ‘safe’ means a rank that does not exceed the actual rank of the kernel</p></li>
<li><p><strong>cut_off</strong> (<em>float</em>) – truncation threshold (absolute value)</p></li>
<li><p><strong>preserve_shape</strong> (<em>bool</em>) – if True keep the original shape and fill them with zeros</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>truncated (smaller) array. If preserving the shape, keep the shape and insert zeros in the truncated parts.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.apply_laplacian_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">apply_laplacian_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.apply_laplacian_2d" title="Permalink to this definition"></a></dt>
<dd><p>Convolve a 2d domain with a 2d Laplacian operator in the <em>matrix from</em>. This is based on a 3x3 base     Laplacian kernel when finite differencing (the same as the Laplacian base kernel in Jacobi).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>matrix from</em> of <span class="math notranslate nohighlight">\(Ax=b\)</span> is <span class="math notranslate nohighlight">\(L*X=B\)</span></p>
<dl class="simple">
<dt>where</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(L\)</span>: Laplacian operator</p></li>
<li><p><span class="math notranslate nohighlight">\(*\)</span>: convolution operator</p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span>: given or unknown matrix, depending on the Poisson equation we are solving for.</p></li>
<li><p><span class="math notranslate nohighlight">\(B\)</span>: given or unknown rhs matrix, depending on the Poisson equation we are solving for.</p></li>
</ul>
</dd>
</dl>
<p>All matrices have the same dimension in the <em>matrix form</em>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Each dimension must be at least 3 to allow for fetching the marginal wall cells.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>ndarray</em>) – input 2d matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(L*X\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.apply_laplacian_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">apply_laplacian_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.apply_laplacian_3d" title="Permalink to this definition"></a></dt>
<dd><p>Convolve a 3d domain with a 3d Laplacian operator in the <em>matrix from</em>. This is based on a 3x3x3 base     Laplacian kernel when finite differencing (the same as the Laplacian base kernel in Jacobi).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>matrix from</em> of <span class="math notranslate nohighlight">\(Ax=b\)</span> is <span class="math notranslate nohighlight">\(L*X=B\)</span></p>
<dl class="simple">
<dt>where</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(L\)</span>: Laplacian operator</p></li>
<li><p><span class="math notranslate nohighlight">\(*\)</span>: convolution operator</p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span>: given or unknown tensor, depending on the Poisson equation we are solving for.</p></li>
<li><p><span class="math notranslate nohighlight">\(B\)</span>: given or unknown rhs tensor, depending on the Poisson equation we are solving for.</p></li>
</ul>
</dd>
</dl>
<p>All tensors have the same dimension in the <em>matrix form</em>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Each dimension must be at least 3 to allow for fetching the marginal wall cells.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>ndarray</em>) – input 3d tensor</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(L*X\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.bivariate_gaussian_normalized">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">bivariate_gaussian_normalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ef_rad</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.bivariate_gaussian_normalized" title="Permalink to this definition"></a></dt>
<dd><p>Generate a normalized 2d gaussian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – x values</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – y values</p></li>
<li><p><strong>x0</strong> (<em>float</em>) – mean x</p></li>
<li><p><strong>y0</strong> (<em>float</em>) – mean y</p></li>
<li><p><strong>ef_rad</strong> (<em>float</em>) – effective radius, full-width-half-maximum</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>normalized 2d Gaussian</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_abs_rel_error">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_abs_rel_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_abs_rel_error" title="Permalink to this definition"></a></dt>
<dd><p>Compute absolute and relative errors, with <code class="code docutils literal notranslate"><span class="pre">M1</span></code> being the reference matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M1</strong> (<em>ndarray</em>) – reference matrix</p></li>
<li><p><strong>M2</strong> (<em>ndarray</em>) – test matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>absolute error, relative error in %</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_conv_padding">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_conv_padding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convolution_kernel_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_conv_padding" title="Permalink to this definition"></a></dt>
<dd><p>Compute the padding required to compensate for shrinkage due to convolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>convolution_kernel_size</strong> (<em>int</em>) – size of a square convolution kernel</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>required padding size</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_gradient_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_gradient_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">half_dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_gradient_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute the gradient of a scalar field. The output would be a 2d vector field.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This computes the gradient for the central cell. If, for example, we are interested
in a MACGrid setup we need to be careful how to interpret this.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default values are recommended: <code class="code docutils literal notranslate"><span class="pre">grad_scale</span> <span class="pre">=</span> <span class="pre">2.0</span></code>, <code class="code docutils literal notranslate"><span class="pre">half_dx</span> <span class="pre">=</span> <span class="pre">0.5</span></code></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input scalar field</p></li>
<li><p><strong>grad_scale</strong> (<em>float</em>) – gradient scale (Default= <code class="code docutils literal notranslate"><span class="pre">2.0</span></code>)</p></li>
<li><p><strong>half_dx</strong> (<em>float</em>) – half the cell size (Default= <code class="code docutils literal notranslate"><span class="pre">0.5</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2d vector field of gradients</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_l1_norm_error">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_l1_norm_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_l1_norm_error" title="Permalink to this definition"></a></dt>
<dd><p>Compute <em>L1</em> norm of the difference between two matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M1</strong> (<em>ndarray</em>) – input matrix</p></li>
<li><p><strong>M2</strong> (<em>ndarray</em>) – input matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>error scalar</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_norm">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_norm" title="Permalink to this definition"></a></dt>
<dd><p>Different norms of the matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input matrix</p></li>
<li><p><strong>method</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.NormOptions" title="src.helper.commons.NormOptions"><em>NormOptions</em></a>) – frobenius, mse, infinite</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>error scalar</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_residual_poisson_operator">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_residual_poisson_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_dimension</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_residual_poisson_operator" title="Permalink to this definition"></a></dt>
<dd><p>Compute <em>L2-norm</em> residual <span class="math notranslate nohighlight">\(r= L*X - B\)</span> using 2d or 3d Laplacian <span class="math notranslate nohighlight">\(L\)</span> in the <em>matrix form</em>
(equivalent to <span class="math notranslate nohighlight">\(r=Ax-b\)</span> in the <em>vector form</em>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is based on the <em>matrix form</em> setup, excluding wall boundaries by one cell, and         is only valid for <em>inverse</em> Poisson equation. The <em>forward</em> Poisson version needs         to be implemented.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is not safe if <strong>not</strong> excluding wall boundaries. Use this function in subdomains to properly
exclude the wall boundaries.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>B</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>solver_dimension</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.SolverDimension" title="src.helper.commons.SolverDimension"><em>SolverDimension</em></a>) – 2d or 3d</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>residual scalar</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_residual_poisson_tensor_operator">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_residual_poisson_tensor_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_dimension</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_residual_poisson_tensor_operator" title="Permalink to this definition"></a></dt>
<dd><p>Compute residual matrix/tensor <span class="math notranslate nohighlight">\(r= L*X - B\)</span> using 2d or 3d Laplacian <span class="math notranslate nohighlight">\(L\)</span> in the <em>matrix form</em>
(equivalent to <span class="math notranslate nohighlight">\(r=Ax-b\)</span> in the <em>vector form</em>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is based on the <em>matrix form</em> setup, excluding wall boundaries by one cell, and         is only valid for <em>inverse</em> Poisson equation. The <em>forward</em> Poisson version needs         to be implemented.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is not safe if <strong>not</strong> excluding wall boundaries. Use this function in subdomains to properly
exclude the wall boundaries.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>B</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>solver_dimension</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.SolverDimension" title="src.helper.commons.SolverDimension"><em>SolverDimension</em></a>) – 2d or 3d</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>residual matrix/tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_residual_subdomain">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_residual_subdomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_dimension</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_residual_subdomain" title="Permalink to this definition"></a></dt>
<dd><p>Compute subdomain <em>L2-norm</em> residual <span class="math notranslate nohighlight">\(r= L*X - B\)</span> using 2d or 3d Laplacian <span class="math notranslate nohighlight">\(L\)</span> in the <em>matrix form</em>
(equivalent to <span class="math notranslate nohighlight">\(r=Ax-b\)</span> in the <em>vector form</em>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is based on the <em>matrix form</em> setup, excluding wall boundaries by one cell, and         is only valid for <em>inverse</em> Poisson equation. The <em>forward</em> Poisson version needs         to be implemented.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>B</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>sub_shape</strong> (<em>2-tuple</em><em> or </em><em>3-tuple</em>) – subdomain shape, 2d or 3d</p></li>
<li><p><strong>solver_dimension</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.SolverDimension" title="src.helper.commons.SolverDimension"><em>SolverDimension</em></a>) – 2d or 3d</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>residual (2norm scalar)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_residual_subdomain_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_residual_subdomain_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_residual_subdomain_2d" title="Permalink to this definition"></a></dt>
<dd><p>Compute 2d subdomain <em>L2-norm</em> residual <span class="math notranslate nohighlight">\(r= L*X - B\)</span> using 2d Laplacian <span class="math notranslate nohighlight">\(L\)</span> in the <em>matrix form</em>
(equivalent to <span class="math notranslate nohighlight">\(r=Ax-b\)</span> in the <em>vector form</em>).</p>
<blockquote>
<div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is based on the <em>matrix form</em> setup, excluding wall boundaries by one cell, and         is only valid for <em>inverse</em> Poisson equation. The <em>forward</em> Poisson version needs         to be implemented.</p>
</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>B</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>sub_shape</strong> (<em>2-tuple</em>) – subdomain shape</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>residual (2norm scalar)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_residual_subdomain_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_residual_subdomain_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_residual_subdomain_3d" title="Permalink to this definition"></a></dt>
<dd><p>Compute 3d subdomain <em>L2-norm</em> residual <span class="math notranslate nohighlight">\(r= L*X - B\)</span> using 2d Laplacian <span class="math notranslate nohighlight">\(L\)</span> in the <em>matrix form</em>
(equivalent to <span class="math notranslate nohighlight">\(r=Ax-b\)</span> in the <em>vector form</em>).</p>
<blockquote>
<div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is based on the <em>matrix form</em> setup, excluding wall boundaries by one cell, and         is only valid for <em>inverse</em> Poisson equation. The <em>forward</em> Poisson version needs         to be implemented.</p>
</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>B</strong> (<em>ndarray</em>) – input in <span class="math notranslate nohighlight">\(L*X=B\)</span></p></li>
<li><p><strong>sub_shape</strong> (<em>3-tuple</em>) – subdomain shape</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>residual (2norm scalar)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.compute_ssim">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">compute_ssim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.compute_ssim" title="Permalink to this definition"></a></dt>
<dd><p>Compute <em>SSIM</em> - Structural Similarity Index.</p>
<p>Measure the <em>perceptual</em> similarity and difference between two images, as well as the gradient and the mean SSIM.
Check out <a class="reference external" href="https://en.wikipedia.org/wiki/Structural_similarity">the formal definition</a> and these
<a class="reference external" href="https://ece.uwaterloo.ca/~z70wang/research/ssim/">examples</a>.</p>
<p><strong>How to compute the SSIM difference</strong>:</p>
<p><span class="math notranslate nohighlight">\(S\)</span> is the local similarity index. It is usually expected to be in [0, 1] but it can also be [-1, 1] where
negative values mean the same structure but with inverted values (it is due to a cross product).
Since we do not really care about inversion we take the absolute value of <span class="math notranslate nohighlight">\(S\)</span> to make it [0, 1].
The computed difference, working with everything normalized, gives <code class="code docutils literal notranslate"><span class="pre">0</span></code> when the two matrices are exactly the
same (because <span class="math notranslate nohighlight">\(S\)</span> will be 1), and <code class="code docutils literal notranslate"><span class="pre">1</span></code> when they are completely different (<span class="math notranslate nohighlight">\(S\)</span> will be 0).</p>
<p><em>Suggested vragne for plotting: [-1, 1].</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_image</strong> (<em>ndarray</em>) – </p></li>
<li><p><strong>ref_image</strong> (<em>ndarray</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ssim_image</strong> - structural similarity indices. The full SSIM image. This is only returned if <cite>full</cite> is set         to <code class="code docutils literal notranslate"><span class="pre">True</span></code></p></li>
<li><p><strong>ssim_diff</strong> - structural difference</p></li>
<li><p><strong>ssim_grad</strong> - structural similarity gradient</p></li>
<li><p><strong>ssim_mean</strong> - mean ssim scalar value</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.construct_laplacian_nd_vector_friendly">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">construct_laplacian_nd_vector_friendly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_definite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neumann</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">singularity_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.construct_laplacian_nd_vector_friendly" title="Permalink to this definition"></a></dt>
<dd><p>Construct the Laplacian matrix for the <em>vector from</em> of <span class="math notranslate nohighlight">\(Ax=b\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is the Laplacian.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The system size in <span class="math notranslate nohighlight">\(Ax=b\)</span> is the size of the vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(b\)</span> in the <em>vector form</em>, and         can be achieved from the size of the Laplacian matrix:</p>
<ul class="simple">
<li><p><em>2D</em> : <span class="math notranslate nohighlight">\(\sqrt{dim(A)}\)</span></p></li>
<li><p><em>3D</em> : <span class="math notranslate nohighlight">\(\sqrt[3]{dim(A)}\)</span></p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.SolverDimension" title="src.helper.commons.SolverDimension"><em>SolverDimension</em></a>) – D2 or D3</p></li>
<li><p><strong>base_size</strong> (<em>int</em>) – for a square matrix, number of rows or columns (or depth in 3D).
This will be used to compute the Laplacian size.
e.g. base_size = 5 : 2D Laplacian <span class="math notranslate nohighlight">\(5^2\)</span>, 3D Laplacian <span class="math notranslate nohighlight">\(5^3\)</span></p></li>
<li><p><strong>positive_definite</strong> (<em>bool</em>) – just a flag to flip the sign of the matrix to have positive values on
the diagonals. Default is negative diagonals (<code class="code docutils literal notranslate"><span class="pre">False</span></code>), to make it consistent with the Poisson kernel generator.
In our case where we are just interested in convergence properties this sign flip does not change anything</p></li>
<li><p><strong>neumann</strong> (<em>bool</em>) – with Neumann boundary condition (Default= <code class="code docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><strong>singularity_value</strong> (<em>float</em>) – regularization factor for treating the ill-conditioned matrix (Default= <code class="code docutils literal notranslate"><span class="pre">1</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>square/cubic Laplacian matrix/tensor in 2D/3D</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.convergence_rate">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">convergence_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">defects</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.convergence_rate" title="Permalink to this definition"></a></dt>
<dd><p>Compute the convergence for a multi-grid setup. Inspired by
<a class="reference external" href="https://julianroth.org/documentation/multigrid/Multigrid.html">this work</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>defects</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>average convergence rate</p></li>
<li><p>convergence rates</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.convolve_filter_1d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">convolve_filter_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.convolve_filter_1d" title="Permalink to this definition"></a></dt>
<dd><p>Convolve a 2d matrix with a 1d filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – 2d input matrix. It does not have to be square</p></li>
<li><p><strong>filter_1d</strong> (<em>ndarray</em>) – convolutional filter</p></li>
<li><p><strong>orientation</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.ConvolutionOrientation" title="src.helper.commons.ConvolutionOrientation"><em>ConvolutionOrientation</em></a>) – horizontal or vertical filter</p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – number of lateral elements to skip in the convolution. This helps with saving computation
time when having redundant padding (Typical value= <code class="code docutils literal notranslate"><span class="pre">0</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>convolved matrix with shrunk size in the given orientation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.convolve_filter_obj_aware_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">convolve_filter_obj_aware_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collision_mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.convolve_filter_obj_aware_2d" title="Permalink to this definition"></a></dt>
<dd><p>Convolve a 2d data domain with a 1d filter of given orientation. Neumann boundary treatment
around in-domain solid object.</p>
<p>We use <em>Mirror Marching</em> algorithm to enforce Neumann boundary condition. See paper.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix to be convolved on</p></li>
<li><p><strong>filter_1d</strong> (<em>ndarray</em>) – convolutional filter</p></li>
<li><p><strong>orientation</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.ConvolutionOrientation" title="src.helper.commons.ConvolutionOrientation"><em>ConvolutionOrientation</em></a>) – filter orientation, horizontal or vertical</p></li>
<li><p><strong>collision_mask</strong> (<em>ndarray</em>) – 2d object solid mask as in-domain collider</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>convolved matrix with shrunk size in the given orientation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.convolve_filter_wall_aware_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">convolve_filter_wall_aware_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.convolve_filter_wall_aware_2d" title="Permalink to this definition"></a></dt>
<dd><p>Convolve a 2d data domain with a 1d filter of given orientation. Neumann boundary
treatment around domain walls.</p>
<p>We use <em>Mirror Marching</em> algorithm to enforce Neumann boundary condition. See paper.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix to be convolved on</p></li>
<li><p><strong>filter_1d</strong> (<em>ndarray</em>) – convolutional filter</p></li>
<li><p><strong>orientation</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.ConvolutionOrientation" title="src.helper.commons.ConvolutionOrientation"><em>ConvolutionOrientation</em></a>) – filter orientation, horizontal or vertical</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>convolved matrix with shrunk size in the given orientation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.convolve_filter_wall_aware_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">convolve_filter_wall_aware_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.convolve_filter_wall_aware_3d" title="Permalink to this definition"></a></dt>
<dd><p>Convolve a 3d data domain with a 1d filter of given orientation. Neumann boundary treatment around domain walls.</p>
<p>We use <em>Mirror Marching</em> algorithm to enforce Neumann boundary condition. See paper.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 3d matrix (tensor) to be convolved on</p></li>
<li><p><strong>filter_1d</strong> (<em>ndarray</em>) – convolutional filter</p></li>
<li><p><strong>orientation</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.ConvolutionOrientation" title="src.helper.commons.ConvolutionOrientation"><em>ConvolutionOrientation</em></a>) – filter orientation, horizontal, vertical, or fiber (depth)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>convolved tensor with shrunk size in the given orientation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.convolve_kernel_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">convolve_kernel_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.convolve_kernel_2d" title="Permalink to this definition"></a></dt>
<dd><p>Convolve the input 2d matrix with a kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input matrix. It does not have to be square.</p></li>
<li><p><strong>kernel</strong> (<em>ndarray</em>) – convolutional kernel</p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – number of lateral elements to skip in the convolution. This helps with saving computation
time when having redundant padding (Default= <code class="code docutils literal notranslate"><span class="pre">0</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>convolved matrix with shrunk size.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.convolve_kernel_single_pass_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">convolve_kernel_single_pass_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.convolve_kernel_single_pass_2d" title="Permalink to this definition"></a></dt>
<dd><p>Convolve the kernel with a matrix of equal size to give one scalar output. No sliding windows is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input matrix</p></li>
<li><p><strong>kernel</strong> (<em>ndarray</em>) – convolutional kernel matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>scalar output</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.expand_with_padding">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">expand_with_padding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts_boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.expand_with_padding" title="Permalink to this definition"></a></dt>
<dd><p>Add equal padding to each side of the matrix with a fixed value (wall padding).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – 2d or 3d matrix</p></li>
<li><p><strong>pad_size</strong> (<em>int</em>) – </p></li>
<li><p><strong>pad_value</strong> (<em>int</em>) – </p></li>
<li><p><strong>dim</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.SolverDimension" title="src.helper.commons.SolverDimension"><em>SolverDimension</em></a>) – 2D or 3D</p></li>
<li><p><strong>opts_boundary</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsBoundary" title="src.helper.commons.OptionsBoundary"><em>OptionsBoundary</em></a>) – Optional. If available, enforce padding on specific walls only.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new padded matrix if pad_size != 0, else return the original matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.expand_with_padding_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">expand_with_padding_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts_boundary_detailed_wall</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.expand_with_padding_2d" title="Permalink to this definition"></a></dt>
<dd><p>Add equal padding to each side of the matrix with a fixed value (wall padding).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – 2d matrix</p></li>
<li><p><strong>pad_size</strong> (<em>int</em>) – </p></li>
<li><p><strong>pad_value</strong> (<em>int</em>) – </p></li>
<li><p><strong>opts_boundary_detailed_wall</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsBoundary" title="src.helper.commons.OptionsBoundary"><em>OptionsBoundary</em></a>) – Optional. If available, enforce padding on specific walls only.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new padded matrix if <code class="code docutils literal notranslate"><span class="pre">pad_size</span> <span class="pre">!=</span> <span class="pre">0</span></code>, else return the original matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.expand_with_padding_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">expand_with_padding_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts_boundary_detailed_wall</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.expand_with_padding_3d" title="Permalink to this definition"></a></dt>
<dd><p>Add equal padding to each side of the matrix with a fixed value (wall padding).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – 3d matrix</p></li>
<li><p><strong>pad_size</strong> (<em>int</em>) – </p></li>
<li><p><strong>pad_value</strong> (<em>int</em>) – </p></li>
<li><p><strong>opts_boundary_detailed_wall</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsBoundary" title="src.helper.commons.OptionsBoundary"><em>OptionsBoundary</em></a>) – Optional. If available, enforce padding on specific walls only.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new padded matrix if <code class="code docutils literal notranslate"><span class="pre">pad_size</span> <span class="pre">!=</span> <span class="pre">0</span></code>, else return the original matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.extract_frame_values">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">extract_frame_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thickness</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.extract_frame_values" title="Permalink to this definition"></a></dt>
<dd><p>Extract the elements of the outer frame of the 2d matrix.</p>
<p>The rest of the matrix will be zero. The frame starts from the skip_margin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – 2d input matrix to extract from</p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – offset from sides</p></li>
<li><p><strong>thickness</strong> (<em>int</em>) – thickness of the frame in terms of number of elements</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new 2d matrix with the extracted frame values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.extract_from_center_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">extract_from_center_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.extract_from_center_2d" title="Permalink to this definition"></a></dt>
<dd><p>Extract a sub-matrix from the center.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Both the input matrix and the extraction shape must indicate a symmetrical shape with         odd number for rows and columns.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>sub_shape</strong> (<em>tuple</em>) – tuple (rows, cols) of the sub matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sub-matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.extract_from_center_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">extract_from_center_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.extract_from_center_3d" title="Permalink to this definition"></a></dt>
<dd><p>Extract a sub-matrix from the center.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Both the input matrix and the extraction shape must indicate a symmetrical shape with        odd number for rows and columns.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 3d matrix</p></li>
<li><p><strong>sub_shape</strong> (<em>tuple</em>) – tuple (rows, cols, depth) of the sub matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sub-matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.find_max_rank_and_filter_size">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">find_max_rank_and_filter_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ranked_filters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_rank</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.find_max_rank_and_filter_size" title="Permalink to this definition"></a></dt>
<dd><p>Return maximum rank and filter size required based on excluding the zero-out elements
of their values set during adaptive truncation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Assuming filters are already adaptively truncated, meaning their small values are
set to zero given a fixed truncation threshold. All filters have the same size, preserving
their original size.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ranked_filters</strong> (<em>ndarray</em>) – 2d array of the shape (ranks, filters)</p></li>
<li><p><strong>safe_rank</strong> (<em>int</em>) – desired input rank. ‘safe’ means a rank that does not exceed the actual rank of the kernel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>max_effective_rank</strong> : maximum rank required</p></li>
<li><p><strong>max_filter_size</strong>: maximum filter size required (max of all ranked filters)</p></li>
<li><p><strong>actual_filter_size</strong>: filter size if there was no truncation</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.frobenius_norm">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">frobenius_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.frobenius_norm" title="Permalink to this definition"></a></dt>
<dd><p>Frobenius norm of the matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> (<em>ndarray</em>) – input matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>error scalar</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.generate_bivariate_gaussian">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">generate_bivariate_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ef_rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.generate_bivariate_gaussian" title="Permalink to this definition"></a></dt>
<dd><p>Generate a normalized 2d gaussian with maximum 1 and minimum 0.</p>
<p>The effective radius (ef_rad) will be automatically computed to get <span class="math notranslate nohighlight">\(\mu_x\)</span> and <span class="math notranslate nohighlight">\(\mu_y\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – size of the 2d matrix</p></li>
<li><p><strong>ef_rad</strong> (<em>float</em>) – effective radius, full-width-half-maximum</p></li>
<li><p><strong>center</strong> (<em>ndarray</em>) – if None, the center of the matrix, else movable center (Default= <code class="code docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2d Gaussian</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.get_1d_array_half_size">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">get_1d_array_half_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trunc_factor_percent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enforce_min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.get_1d_array_half_size" title="Permalink to this definition"></a></dt>
<dd><p>Given 1d array length and a truncation factor (%), compute the new half array size.
Half size excludes the element in the middle. Minimum filter/kernel size should be 3, a half size of 0 means
a convolution of a 1x1 element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<em>int</em>) – size of the 1d array</p></li>
<li><p><strong>trunc_factor_percent</strong> (<em>float</em>) – truncation factor in [0, 1]</p></li>
<li><p><strong>enforce_min_size</strong> (<em>bool</em>) – this is specially used for convolutional stuff. If True, minimum filter/kernel
size should be 3, which is achieved by avoiding a half size of 0. This is necessary to remain consistent
with the Jacobi 3x3 base kernel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>half_size</strong> - new half size</p></li>
<li><p><strong>middle_index</strong> - the index to the middle element</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.get_effective_nonzero_1darray">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">get_effective_nonzero_1darray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.get_effective_nonzero_1darray" title="Permalink to this definition"></a></dt>
<dd><p>Find where non-zero elements are.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arr</strong> – input array</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array with only nonzero elements</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.get_kernel_effective_size">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">get_kernel_effective_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.get_kernel_effective_size" title="Permalink to this definition"></a></dt>
<dd><p>Get the actual convolution kernel size, whether it is full or reduced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>effective kernel size</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.get_kernel_trimmed_size">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">get_kernel_trimmed_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trunc_factor_percent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.get_kernel_trimmed_size" title="Permalink to this definition"></a></dt>
<dd><p>Compute a new kernel size based on a truncation factor % and the original kernel size (assume a square kernel).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel_size</strong> (<em>int</em>) – original kernel size</p></li>
<li><p><strong>trunc_factor_percent</strong> (<em>float</em>) – truncation factor in [0, 1]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new kernel size</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.get_sub_domain_shape">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">get_sub_domain_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_original</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_exclude_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.get_sub_domain_shape" title="Permalink to this definition"></a></dt>
<dd><p>Compute the size of the subdomain data given the numbers of cells to exclude from each side.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data_original</strong> (<em>ndarray</em>) – original data matrix, either 2d or 3d</p></li>
<li><p><strong>num_exclude_cell</strong> (<em>int</em>) – number of cells to exclude from each side</p></li>
<li><p><strong>dim</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.SolverDimension" title="src.helper.commons.SolverDimension"><em>SolverDimension</em></a>) – 2D or 3D</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2d or 3d shape</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.get_truncate_indices">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">get_truncate_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_off</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.get_truncate_indices" title="Permalink to this definition"></a></dt>
<dd><p>Find indices of array values larger than or equal to the cut_off value.</p>
<p>We get the indices that <em>should be kept</em>. For a symmetrical array with larger values around the center,
this means an index list of the sub-array spanning a range around the center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>ndarray</em>) – input 1darray</p></li>
<li><p><strong>cut_off</strong> (<em>float</em>) – truncation threshold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cut</strong> - the exact truncation index, cut_indices: all indices that should be kept</p></li>
<li><p><strong>cut_indices</strong> - the index list of all cut values</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Returns <code class="code docutils literal notranslate"><span class="pre">None</span></code> for both if the whole array is subject to truncation (nothing will be left).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.inf_norm">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">inf_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.inf_norm" title="Permalink to this definition"></a></dt>
<dd><p>Infinite norm of the matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> (<em>ndarray</em>) – input matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>error scalar</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.interp_1darray">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">interp_1darray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric_x_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cubic'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.interp_1darray" title="Permalink to this definition"></a></dt>
<dd><p>Interpolate a 1d array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>1darray</em>) – input</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – <code class="code docutils literal notranslate"><span class="pre">1</span></code> no interpolation, <code class="code docutils literal notranslate"><span class="pre">1&gt;</span></code> increased resolution</p></li>
<li><p><strong>kind</strong> (<em>str</em>) – interpolation function (Default=cubic); see <code class="code docutils literal notranslate"><span class="pre">scipy.interpolate</span></code> for options.</p></li>
<li><p><strong>symmetric_x_axis</strong> (<em>bool</em>) – if <code class="code docutils literal notranslate"><span class="pre">True</span></code> add points equally to each side of the array center</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>up-sampled indices and array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.is_active_domain">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">is_active_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.is_active_domain" title="Permalink to this definition"></a></dt>
<dd><p>Check if a certain position of the mask is active (data) domain.</p>
<dl class="simple">
<dt>The marking convention:</dt><dd><ul class="simple">
<li><p>data domain = 0</p></li>
<li><p>solid = 1</p></li>
<li><p>contour = 2 (still part of solid, but with a special flag)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<em>ndarray</em>) – mask matrix</p></li>
<li><p><strong>i</strong> (<em>int</em>) – row index</p></li>
<li><p><strong>j</strong> (<em>int</em>) – column index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the position is part of the active (data) domain</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.is_contour_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">is_contour_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.is_contour_2d" title="Permalink to this definition"></a></dt>
<dd><p>Check if a certain position of the mask is contour.</p>
<dl class="simple">
<dt>The marking convention:</dt><dd><ul class="simple">
<li><p>data domain = 0</p></li>
<li><p>solid = 1</p></li>
<li><p>contour = 2 (still part of solid, but with a special flag)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<em>ndarray</em>) – mask matrix</p></li>
<li><p><strong>i</strong> (<em>int</em>) – row index</p></li>
<li><p><strong>j</strong> (<em>int</em>) – column index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if the position is part of the contour</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.is_solid_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">is_solid_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.is_solid_2d" title="Permalink to this definition"></a></dt>
<dd><p>Check if a certain position of a mask is solid.</p>
<dl class="simple">
<dt>The marking convention:</dt><dd><ul class="simple">
<li><p>data domain = 0</p></li>
<li><p>solid = 1</p></li>
<li><p>contour = 2 (still part of solid, but with a special flag)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<em>ndarray</em>) – mask matrix</p></li>
<li><p><strong>i</strong> (<em>int</em>) – row index</p></li>
<li><p><strong>j</strong> (<em>int</em>) – column index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if it is solid or contour</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.is_wall_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">is_wall_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.is_wall_2d" title="Permalink to this definition"></a></dt>
<dd><p>Check if a certain position of a 2d domain matrix falls in walls.</p>
<p>Walls are 1-cell wide paddings around the domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – domain matrix</p></li>
<li><p><strong>i</strong> (<em>int</em>) – row index</p></li>
<li><p><strong>j</strong> (<em>int</em>) – column index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if it is inside the wall</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.is_wall_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">is_wall_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.is_wall_3d" title="Permalink to this definition"></a></dt>
<dd><p>Check if a certain position of a 3d domain matrix falls in walls.</p>
<p>Walls are 1-cell wide paddings around the domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>3darray</em>) – domain matrix</p></li>
<li><p><strong>i</strong> (<em>int</em>) – row index</p></li>
<li><p><strong>j</strong> (<em>int</em>) – column index</p></li>
<li><p><strong>k</strong> (<em>int</em>) – depth index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if it is inside the wall</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.make_4_tiles_mirrored_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">make_4_tiles_mirrored_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_odd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.make_4_tiles_mirrored_2d" title="Permalink to this definition"></a></dt>
<dd><p>Given the input matrix make <em>even</em> or <em>odd</em> tile block arrangement where the top left block is the</p>
<p>See <a class="reference internal" href="#src.functions.mathlib.make_4_tiles_mirrored_odd_2d" title="src.functions.mathlib.make_4_tiles_mirrored_odd_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_4_tiles_mirrored_odd_2d()</span></code></a> and <a class="reference internal" href="#src.functions.mathlib.make_4_tiles_mirrored_even_2d" title="src.functions.mathlib.make_4_tiles_mirrored_even_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_4_tiles_mirrored_even_2d()</span></code></a> for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>is_odd</strong> (<em>bool</em>) – even or odd arrangement</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>even or odd mirrored matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.make_4_tiles_mirrored_even_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">make_4_tiles_mirrored_even_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.make_4_tiles_mirrored_even_2d" title="Permalink to this definition"></a></dt>
<dd><p>Given the input matrix make 4 tiles block <em>even</em> arrangement where the top left block is the input,
the top right block is the mirror of the first block and the two bottom blocks are the
mirrors of the top blocks.</p>
<p>For example, given</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
1 &amp; 2 \\
a &amp; b
\end{bmatrix}\end{split}\]</div>
<p>its 4-tiles <em>even</em> structure looks like this:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\mathbf{1} &amp; \mathbf{2} &amp; 2 &amp; 1 \\
\mathbf{a} &amp; \mathbf{b} &amp; b &amp; a \\
a &amp; b &amp; b &amp; a \\
1 &amp; 2 &amp; 2 &amp; 1
\end{bmatrix}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>even mirrored matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.make_4_tiles_mirrored_odd_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">make_4_tiles_mirrored_odd_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.make_4_tiles_mirrored_odd_2d" title="Permalink to this definition"></a></dt>
<dd><p>Given the input matrix make 4 tiles block <em>odd</em> arrangement where the top left block is the input,
the top right block is the mirror of the first block and the two bottom blocks are the mirrors of the top blocks.</p>
<p>For example, given</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
1 &amp; 2 \\
a &amp; b
\end{bmatrix}\end{split}\]</div>
<p>its 4-tiles <em>even</em> structure looks like this:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\mathbf{1} &amp; \mathbf{2} &amp; 1 \\
\mathbf{a} &amp; \mathbf{b} &amp; a \\
1 &amp; 2 &amp; 1
\end{bmatrix}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>odd mirrored matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.make_9_tiles_mirrored_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">make_9_tiles_mirrored_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.make_9_tiles_mirrored_2d" title="Permalink to this definition"></a></dt>
<dd><p>Given the input matrix make 9 tiles arrangement, where the central block is the input,
and each of the remaining 8 tiles are the mirrored of their neighbours. Each edge separating two tiles acts as the axis the mirrored image is flipped. The output therefore has 3x the size of the original matrix.</p>
<p>For example for a 2x2 matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
1 &amp; 2 \\
a &amp; b
\end{bmatrix}\end{split}\]</div>
<p>its 9-tiles structure looks like this, with the matrix being the central block:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
b &amp; a &amp; a &amp; b &amp; b &amp; a \\
2 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 1 \\
2 &amp; 1 &amp; \mathbf{1} &amp; \mathbf{2} &amp; 2 &amp; 1 \\
b &amp; a &amp; \mathbf{a} &amp; \mathbf{b} &amp; b &amp; a \\
b &amp; a &amp; a &amp; b &amp; b &amp; a \\
2 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 1
\end{bmatrix}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>9-tiles matrix, with 3 times the size of the input matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.mark_contour_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">mark_contour_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.mark_contour_2d" title="Permalink to this definition"></a></dt>
<dd><p>Mark a certain position of the mask to be contour.</p>
<dl class="simple">
<dt>The marking convention:</dt><dd><ul class="simple">
<li><p>data domain = 0</p></li>
<li><p>solid = 1</p></li>
<li><p>contour = 2 (still part of solid, but with a special flag)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<em>ndarray</em>) – mask matrix</p></li>
<li><p><strong>i</strong> (<em>int</em>) – row index</p></li>
<li><p><strong>j</strong> (<em>int</em>) – column index</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.mark_solid_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">mark_solid_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.mark_solid_2d" title="Permalink to this definition"></a></dt>
<dd><p>Mark a certain position of the mask to be solid.</p>
<dl class="simple">
<dt>The marking convention:</dt><dd><ul class="simple">
<li><p>data domain = 0</p></li>
<li><p>solid = 1</p></li>
<li><p>contour = 2 (still part of solid, but with a special flag)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<em>ndarray</em>) – mask matrix</p></li>
<li><p><strong>i</strong> (<em>int</em>) – row index</p></li>
<li><p><strong>j</strong> (<em>int</em>) – column index</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.mre">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">mre</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_err</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.mre" title="Permalink to this definition"></a></dt>
<dd><p>Mean relative error of two matrices. If only one matrix is given, returns the average of <em>L1</em> norm of x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – input array/matrix</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – input array/matrix, optional (Default= <code class="code docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><strong>abs_err</strong> (<em>bool</em>) – if <code class="code docutils literal notranslate"><span class="pre">True</span></code> use the absolute values of the inputs to compute the error
(Default= <code class="code docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>2-tuple of ints</em>) – specifies the axis along which to compute the vector norms (Default= <code class="code docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>error scalar</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.ms_norm">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">ms_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.ms_norm" title="Permalink to this definition"></a></dt>
<dd><p>Mean squared norm of the matrix. Element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> (<em>ndarray</em>) – input matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>error scalar</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.mse">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">mse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.mse" title="Permalink to this definition"></a></dt>
<dd><p>Mean squared error of two matrices. If only one is given, returns the <em>L2-norm</em> of x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ndarray</em>) – input array/matrix</p></li>
<li><p><strong>y</strong> (<em>ndarray</em>) – input array/matrix, optional (Default= <code class="code docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>2-tuple of ints</em>) – specifies the axis along which to compute the vector norms (Default= <code class="code docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>error scalar</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.normalize_range">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">normalize_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.normalize_range" title="Permalink to this definition"></a></dt>
<dd><p>Normalize the matrix values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input matrix</p></li>
<li><p><strong>symmetric</strong> (<em>bool</em>) – [-1, +1] if <code class="code docutils literal notranslate"><span class="pre">True</span></code>, else [0, +1], optional (Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>normalized matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.outer_product_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">outer_product_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.outer_product_2d" title="Permalink to this definition"></a></dt>
<dd><p>Outer product of two vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – first vertical vector</p></li>
<li><p><strong>b</strong> – second horizontal vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(a \times b\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.post_process_obj_boundary_enforcement_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">post_process_obj_boundary_enforcement_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collision_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.post_process_obj_boundary_enforcement_2d" title="Permalink to this definition"></a></dt>
<dd><p>Boundary enforcement to make sure domain values give the right edge gradient (Neumann). Usually used as an     optional last step clean up after the Poisson equation solve.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Complex Object Boundary</em></p>
<p>This is not perfect. For corner cells on the object there is a race condition as
what value we should use to copy from. This is because there are more than one
cell in the active domain to copy from. A remedy would be to take average.
Nonetheless, because we don’t really compute the gradient, and we are just interested
in the active domain values, we skip improving this step.</p>
<p>This is for the collocated grid.</p>
<p>For MACGrid we do not really have to worry about the interior cells inside the
object when solving, for instance, for the pressure. The pressure gradient on the
edge cells is already ensured to be zero during the Jacobi iterations, so we do not
have to explicitly set the object cell values.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>collision_mask</strong> (<em>ndarray</em>) – 2d object solid mask as in-domain collider</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options (contains boundary enforcement type, but only supports Neumann for now)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.post_process_wall_boundary_enforcement_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">post_process_wall_boundary_enforcement_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.post_process_wall_boundary_enforcement_2d" title="Permalink to this definition"></a></dt>
<dd><p>Boundary enforcement to make sure domain values give the right edge gradient (Neumann). Usually used as an     optional last step clean up after the Poisson equation solve. Walls only.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options (contains boundary enforcement type, but only supports Neumann for now)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.post_process_wall_boundary_enforcement_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">post_process_wall_boundary_enforcement_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.post_process_wall_boundary_enforcement_3d" title="Permalink to this definition"></a></dt>
<dd><p>Boundary enforcement to make sure domain values give the right edge gradient (Neumann). Usually used as an     optional last step clean up after the Poisson equation solve. Walls only.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 3d matrix</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options (contains boundary enforcement type, but only supports Neumann for now)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_frame_boundary_from_matrix">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_frame_boundary_from_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thickness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_frame_boundary_from_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Set the boundary values of the given matrix from another matrix.</p>
<p>The extracted boundary elements can have larger than one-cell thickness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – 2d target matrix to edit</p></li>
<li><p><strong>thickness</strong> (<em>int</em>) – thickness of the boundary</p></li>
<li><p><strong>source</strong> (<em>ndarray</em>) – 2d source matrix to extract the boundary values from</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>modified matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_frame_fixed_value">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_frame_fixed_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thickness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bottom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_frame_fixed_value" title="Permalink to this definition"></a></dt>
<dd><p>Set the elements of the outer frame of the 2d matrix to the given value.</p>
<p>The frame starts from the skip_margin.
The values in the skip_margin and inside the matrix (excluding frame) will remain intact.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – offset from sides</p></li>
<li><p><strong>thickness</strong> (<em>int</em>) – thickness of the frame in terms of number of elements</p></li>
<li><p><strong>value</strong> (<em>float</em>) – the values inside the frame (fixed for all)</p></li>
<li><p><strong>left</strong> (<em>bool</em>) – apply the left side of the frame</p></li>
<li><p><strong>right</strong> (<em>bool</em>) – apply the right side of the frame</p></li>
<li><p><strong>top</strong> (<em>bool</em>) – apply the top side of the frame</p></li>
<li><p><strong>bottom</strong> (<em>bool</em>) – apply the bottom side of the frame</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>overwritten input matrix with the frame values</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_obj_bound_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_obj_bound_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">here_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collision_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_obj_bound_2d" title="Permalink to this definition"></a></dt>
<dd><p>Boundary condition enforcement on a specific cell of the solid object inside the domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>here_index</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.Vector2DInt" title="src.helper.commons.Vector2DInt"><em>Vector2DInt</em></a>) – cell index</p></li>
<li><p><strong>collision_mask</strong> (<em>ndarray</em>) – 2d object solid mask as in-domain collider</p></li>
<li><p><strong>bound_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.BoundaryType" title="src.helper.commons.BoundaryType"><em>BoundaryType</em></a>) – boundary enforcement type. Currently only supports Neumann on cell edge</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_obj_bound_neumann_edge_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_obj_bound_neumann_edge_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collision_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">here_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_obj_bound_neumann_edge_2d" title="Permalink to this definition"></a></dt>
<dd><p>Enforce Pure Neumann boundary condition on a specific cell of the solid object inside the domain.</p>
<p>Set the wall values from the adjacent interior domain cell. Zero gradient on the edge, i.e. the boundary is     defined on the edge separating the interior and the exterior cells.</p>
<p>If current cell is obstacle, do nothing.
If neighbour cell is wall, consider that the lateral solid value has the same value as ‘here’ to
enforce Neumann boundary (<span class="math notranslate nohighlight">\(dp/dn=0\)</span>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Complex Object Boundary</em></p>
<p>This is not perfect. For corner cells on the object there is a race condition as
what value we should use to copy from. This is because there are more than one
cell in the active domain to copy from. A remedy would be to take average.
Nonetheless, because we don’t really compute the gradient, and we are just interested
in the active domain values, we skip improving this step.</p>
<p>This is for the collocated grid.</p>
<p>For MACGrid we do not really have to worry about the interior cells inside the
object when solving, for instance, for the pressure. The pressure gradient on the
edge cells is already ensured to be zero during the Jacobi iterations, so we do not
have to explicitly set the object cell values.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>collision_mask</strong> (<em>ndarray</em>) – 2d object solid mask as in-domain collider</p></li>
<li><p><strong>here_index</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.Vector2DInt" title="src.helper.commons.Vector2DInt"><em>Vector2DInt</em></a>) – cell index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_padding_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_padding_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_padding_2d" title="Permalink to this definition"></a></dt>
<dd><p>Set the padding region of the input 2d matrix with the padding value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>padding_size</strong> (<em>int</em>) – thickness of the padding region</p></li>
<li><p><strong>padding_value</strong> (<em>int</em>) – const value to be put in the padding region</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>padded matrix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_padding_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_padding_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_padding_3d" title="Permalink to this definition"></a></dt>
<dd><p>Set the padding region of the input 3d matrix with the padding value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 3d matrix</p></li>
<li><p><strong>padding_size</strong> (<em>int</em>) – thickness of the padding region</p></li>
<li><p><strong>padding_value</strong> (<em>int</em>) – const value to be put in the padding region</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>padded matrix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_single_cell_wall_bound_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_single_cell_wall_bound_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">here_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_single_cell_wall_bound_2d" title="Permalink to this definition"></a></dt>
<dd><p>Boundary condition enforcement on a specific cell of the domain walls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>here_index</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.Vector2DInt" title="src.helper.commons.Vector2DInt"><em>Vector2DInt</em></a>) – cell index</p></li>
<li><p><strong>bound_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.BoundaryType" title="src.helper.commons.BoundaryType"><em>BoundaryType</em></a>) – boundary enforcement type. Currently only supports Neumann on cell edge</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_single_cell_wall_bound_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_single_cell_wall_bound_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">here_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_single_cell_wall_bound_3d" title="Permalink to this definition"></a></dt>
<dd><p>Boundary condition enforcement on a specific cell of the domain walls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 3d matrix</p></li>
<li><p><strong>here_index</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.Vector3DInt" title="src.helper.commons.Vector3DInt"><em>Vector3DInt</em></a>) – cell index</p></li>
<li><p><strong>bound_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.BoundaryType" title="src.helper.commons.BoundaryType"><em>BoundaryType</em></a>) – boundary enforcement type. Currently only supports Neumann on cell edge</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_single_cell_wall_neumann_edge_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_single_cell_wall_neumann_edge_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">here_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_single_cell_wall_neumann_edge_2d" title="Permalink to this definition"></a></dt>
<dd><p>Enforce Pure Neumann boundary condition on a specific cell of domain walls.</p>
<p>Set the wall values from the adjacent interior domain cell. Zero gradient on the edge, i.e. the boundary is     defined on the edge separating the interior and the wall cells.</p>
<p>If current cell is wall, do nothing.
If neighbour cell is obstacle, consider that the lateral solid value has the same value as ‘here’ to
enforce Neumann boundary (<span class="math notranslate nohighlight">\(dp/dn=0\)</span>).</p>
<p>e.g. when left wall is between <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, then we impose <span class="math notranslate nohighlight">\(x_0 = x_1\)</span>, where     <span class="math notranslate nohighlight">\(x_0\)</span> is inside the wall and <span class="math notranslate nohighlight">\(x_1\)</span> is inside the domain.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We do not care much about what values corner cells are getting because in the
fluids context only the gradient between the wall and the fluid (the cell edges)
matters. The gradient between solid wall cells should not affect the projection
step as it does not make sense to correct the fluid velocity inside the wall.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>here_index</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.Vector2DInt" title="src.helper.commons.Vector2DInt"><em>Vector2DInt</em></a>) – cell index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain walls</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_single_cell_wall_neumann_edge_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_single_cell_wall_neumann_edge_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">here_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_single_cell_wall_neumann_edge_3d" title="Permalink to this definition"></a></dt>
<dd><p>Enforce Pure Neumann boundary condition on a specific cell of domain walls.</p>
<p>Set the wall values from the adjacent interior domain cell. Zero gradient on the edge, i.e. the boundary is     defined on the edge separating the interior and the wall cells.</p>
<p>If current cell is wall, do nothing.
If neighbour cell is obstacle, consider that the lateral solid value has the same value as ‘here’ to
enforce Neumann boundary (<span class="math notranslate nohighlight">\(dp/dn=0\)</span>).</p>
<p>e.g. when left wall is between <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, then we impose <span class="math notranslate nohighlight">\(x_0 = x_1\)</span>, where     <span class="math notranslate nohighlight">\(x_0\)</span> is inside the wall and <span class="math notranslate nohighlight">\(x_1\)</span> is inside the domain.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We do not care much about what values corner cells are getting because in the
fluids context only the gradient between the wall and the fluid (the cell edges)
matters. The gradient between solid wall cells should not affect the projection
step as it does not make sense to correct the fluid velocity inside the wall.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 3d matrix</p></li>
<li><p><strong>here_index</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.Vector3DInt" title="src.helper.commons.Vector3DInt"><em>Vector3DInt</em></a>) – cell index</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain walls</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_submatrix_zero_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_submatrix_zero_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_submatrix_zero_2d" title="Permalink to this definition"></a></dt>
<dd><p>Set the sub-matrix to zero.</p>
<p>The values inside the skip margin will remain intact. If skip_margin is zero, this means no skip margin, which     means set everything to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – 2d input matrix</p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – how many elements from each side should keep their values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>modified matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_submatrix_zero_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_submatrix_zero_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_submatrix_zero_3d" title="Permalink to this definition"></a></dt>
<dd><p>Set the sub-matrix to zero.</p>
<p>The values inside the skip margin will remain intact. If skip_margin is zero, this means no skip margin, which     means set everything to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – 3d input matrix</p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – how many elements from each side should keep their values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>modified matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_wall_bound_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_wall_bound_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_wall_bound_2d" title="Permalink to this definition"></a></dt>
<dd><p>Boundary condition enforcement on the domain walls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>bound_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.BoundaryType" title="src.helper.commons.BoundaryType"><em>BoundaryType</em></a>) – boundary enforcement type. Currently only supports Neumann.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain walls</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_wall_bound_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_wall_bound_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_wall_bound_3d" title="Permalink to this definition"></a></dt>
<dd><p>Boundary condition enforcement on the domain walls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 3d matrix</p></li>
<li><p><strong>bound_type</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.BoundaryType" title="src.helper.commons.BoundaryType"><em>BoundaryType</em></a>) – boundary enforcement type. Currently only supports Neumann.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain walls</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_wall_bound_neumann_center_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_wall_bound_neumann_center_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_wall_bound_neumann_center_2d" title="Permalink to this definition"></a></dt>
<dd><p>Enforce Pure Neumann boundary condition on the cell centers.</p>
<p>Set the wall values from the adjacent interior domain cell. Zero gradient in the center of the interior cell.
To achieve zero gradient in the center of first interior cell we need to equate the wall cell and the second
interior cell.</p>
<p>e.g. when left wall is <span class="math notranslate nohighlight">\(x_1\)</span>, then we impose <span class="math notranslate nohighlight">\(x_0 = x_2\)</span>, where <span class="math notranslate nohighlight">\(x_1\)</span> is the actual boundary     and <span class="math notranslate nohighlight">\(x_0\)</span> is inside the wall.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We do not care much about what values corner cells are getting because in the
fluids context only the gradient between the wall and the fluid (the cell edges)
matters. The gradient between solid wall cells should not affect the projection
step as it does not make sense to correct the fluid velocity inside the wall.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain walls</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_wall_bound_neumann_edge_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_wall_bound_neumann_edge_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_wall_bound_neumann_edge_2d" title="Permalink to this definition"></a></dt>
<dd><p>Enforce Pure Neumann boundary condition on the wall cell edges.</p>
<p>Set the wall values from the adjacent interior domain cell. Zero gradient on the edge, i.e. the boundary is     defined on the edge separating the interior and the wall cells.</p>
<p>e.g. when left wall is between <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, then we impose <span class="math notranslate nohighlight">\(x_0 = x_1\)</span>, where     <span class="math notranslate nohighlight">\(x_0\)</span> is inside the wall and <span class="math notranslate nohighlight">\(x_1\)</span> is inside the domain.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We do not care much about what values corner cells are getting because in the
fluids context only the gradient between the wall and the fluid (the cell edges)
matters. The gradient between solid wall cells should not affect the projection
step as it does not make sense to correct the fluid velocity inside the wall.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain walls</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.set_wall_bound_neumann_edge_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">set_wall_bound_neumann_edge_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.set_wall_bound_neumann_edge_3d" title="Permalink to this definition"></a></dt>
<dd><p>Enforce Pure Neumann boundary condition on the wall cell edges.</p>
<p>Set the wall values from the adjacent interior domain cell. Zero gradient on the edge, i.e. the boundary is     defined on the edge separating the interior and the wall cells.</p>
<p>e.g. when left wall is between <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, then we impose <span class="math notranslate nohighlight">\(x_0 = x_1\)</span>, where     <span class="math notranslate nohighlight">\(x_0\)</span> is inside the wall and <span class="math notranslate nohighlight">\(x_1\)</span> is inside the domain.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We do not care much about what values corner cells are getting because in the
fluids context only the gradient between the wall and the fluid (the cell edges)
matters. The gradient between solid wall cells should not affect the projection
step as it does not make sense to correct the fluid velocity inside the wall.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> (<em>ndarray</em>) – input 3d matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>M</strong> treated domain walls</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_jacobi_matrix_form_no_boundary_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_jacobi_matrix_form_no_boundary_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_residuals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_subdomain_residual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdomain_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_jacobi_matrix_form_no_boundary_2d" title="Permalink to this definition"></a></dt>
<dd><p>Solve the Poisson equation with Jacobi in the <em>matrix form</em> for <em>forward</em> and <em>inverse</em> Poisson equations in     2D with no boundary treatment.</p>
<p>This version of Jacobi solver perfectly matches the results of Poisson filters when boundary treatment is ignored,     in other words, for infinite domains.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use a general Jacobi setup with flexible <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> instead of fixed
values. This allows to adjust the weights based on the type of the Poisson equation.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The computed residual is in the <em>matrix form</em> and is only valid for <em>inverse</em> Poisson setup.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We need one extra cell trimming from sides because of using pure Poisson filters
in comparison. We could have easily added the incomplete Laplacian kernels for the corners
and the cells next to the wall, but this will make it inconsistent with the Jacobi function
used to generate the Poisson kernels.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix; if <em>inverse</em> setup, <span class="math notranslate nohighlight">\(M=B\)</span> in <span class="math notranslate nohighlight">\(L*X=B\)</span>, and if <em>forward</em> setup,          <span class="math notranslate nohighlight">\(M=X\)</span> in in <span class="math notranslate nohighlight">\(L*X=B\)</span>, with <span class="math notranslate nohighlight">\(B\)</span> being the unknown</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options</p></li>
<li><p><strong>do_residuals</strong> (<em>bool</em>) – collect residuals at each iteration (Default= <code class="code docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><strong>is_subdomain_residual</strong> (<em>bool</em>) – compute the residual only for a subdomain (Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
<li><p><strong>subdomain_shape</strong> (<em>tuple</em>) – subdomain size to be used in computing the residuals (Default= <code class="code docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Out</strong> - solution</p></li>
<li><p><strong>residuals</strong> - residual per iteration</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_jacobi_single_padding_obj_collision_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_jacobi_single_padding_obj_collision_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collision_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_jacobi_single_padding_obj_collision_2d" title="Permalink to this definition"></a></dt>
<dd><p>Solve the Poisson equation with Jacobi in the <em>matrix form</em> for <em>forward</em> and <em>inverse</em> Poisson equations in     2D with wall and in-domain boundary treatment of solid objects with complex shapes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use a general Jacobi setup with flexible <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> instead of fixed
values. This allows to adjust the weights based on the type of the Poisson equation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function only supports Neumann boundary treatment on the cell edges. The walls are single cell padding.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix; if <em>inverse</em> setup, <span class="math notranslate nohighlight">\(M=B\)</span> in <span class="math notranslate nohighlight">\(L*X=B\)</span>, and if <em>forward</em> setup,          <span class="math notranslate nohighlight">\(M=X\)</span> in in <span class="math notranslate nohighlight">\(L*X=B\)</span>, with <span class="math notranslate nohighlight">\(B\)</span> being the unknown</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options (contains number of iterations along with many other variables)</p></li>
<li><p><strong>collision_mask</strong> – 2d object solid mask as in-domain collider</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Out</strong> - solution</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_jacobi_single_padding_only_wall_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_jacobi_single_padding_only_wall_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_shape_residual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_jacobi_single_padding_only_wall_2d" title="Permalink to this definition"></a></dt>
<dd><p>Solve the Poisson equation with Jacobi in the <em>matrix form</em> for <em>forward</em> and <em>inverse</em> Poisson equations in     2D with wall Neumann boundary treatment.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use a general Jacobi setup with flexible <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> instead of fixed
values. This allows to adjust the weights based on the type of the Poisson equation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function only supports Neumann boundary treatment on the cell edges. The walls are single cell padding.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix; if <em>inverse</em> setup, <span class="math notranslate nohighlight">\(M=B\)</span> in <span class="math notranslate nohighlight">\(L*X=B\)</span>, and if <em>forward</em> setup,          <span class="math notranslate nohighlight">\(M=X\)</span> in in <span class="math notranslate nohighlight">\(L*X=B\)</span>, with <span class="math notranslate nohighlight">\(B\)</span> being the unknown</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options (contains number of iterations along with many other variables)</p></li>
<li><p><strong>sub_shape_residual</strong> (<em>2-tuple</em>) – subdomain shape used in computing the residual</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Out</strong> - solution</p></li>
<li><p><strong>residuals</strong> - residual per iteration</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_jacobi_single_padding_only_wall_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_jacobi_single_padding_only_wall_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_shape_residual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_jacobi_single_padding_only_wall_3d" title="Permalink to this definition"></a></dt>
<dd><p>Solve the Poisson equation with Jacobi in the <em>matrix form</em> for <em>forward</em> and <em>inverse</em> Poisson equations in     3D with wall Neumann boundary treatment. Walls only.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We use a general Jacobi setup with flexible <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> instead of fixed
values. This allows to adjust the weights based on the type of the Poisson equation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function only supports Neumann boundary treatment on the cell edges. The walls are single cell padding.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 3d tensor; if <em>inverse</em> setup, <span class="math notranslate nohighlight">\(M=B\)</span> in <span class="math notranslate nohighlight">\(L*X=B\)</span>, and if <em>forward</em> setup,          <span class="math notranslate nohighlight">\(M=X\)</span> in in <span class="math notranslate nohighlight">\(L*X=B\)</span>, with <span class="math notranslate nohighlight">\(B\)</span> being the unknown</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options (contains number of iterations along with many other variables)</p></li>
<li><p><strong>sub_shape_residual</strong> (<em>3-tuple</em>) – subdomain shape used in computing the residual</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Out</strong> - solution</p></li>
<li><p><strong>residuals</strong> - residual per iteration</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_jacobi_vector_form">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_jacobi_vector_form</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_subdomain_residual</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_domain_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warm_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_jacobi_vector_form" title="Permalink to this definition"></a></dt>
<dd><p>Solving <span class="math notranslate nohighlight">\(Ax=b\)</span> in <em>vector form</em>.</p>
<p>Works for both 2D and 3D as long as proper <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(b\)</span> is fed in the vector form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>ndarray</em>) – n x n (flat Laplacian)</p></li>
<li><p><strong>b</strong> (<em>ndarray</em>) – n x 1 (rhs)</p></li>
<li><p><strong>max_iterations</strong> (<em>int</em>) – stop when exceeding max iteration</p></li>
<li><p><strong>is_subdomain_residual</strong> (<em>bool</em>) – if computing the residual only for a subdomain.</p></li>
<li><p><strong>sub_domain_shape</strong> (<em>tuple</em>) – the shape of the subdomain if doing subdomain residual.         Must be odd size for proper matrix extraction.</p></li>
<li><p><strong>dim</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.SolverDimension" title="src.helper.commons.SolverDimension"><em>SolverDimension</em></a>) – 2D or 3D, dimension of the problem</p></li>
<li><p><strong>warm_start</strong> – this is loosely based on just copying <span class="math notranslate nohighlight">\(b\)</span>, currently often makes the convergence         worse (Default= <code class="code docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>x</strong> - solution</p></li>
<li><p><strong>residuals</strong> - residual per iteration</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_poisson_full_kernel_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_poisson_full_kernel_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_poisson_full_kernel_2d" title="Permalink to this definition"></a></dt>
<dd><p>Solve the Poisson equation using 2d full Poisson kernel.</p>
<p>Make a convolution pass excluding the boundary, reading it but not updating it.
The Poisson kernel is always square shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input scalar field (matrix)</p></li>
<li><p><strong>kernel</strong> (<em>ndarray</em>) – Poisson square convolutional kernel</p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – number of lateral elements to skip in the convolution. This helps with saving computation
time when having redundant padding (Default= <code class="code docutils literal notranslate"><span class="pre">0</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>solution as scalar field (matrix)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_poisson_separable_filters_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_poisson_separable_filters_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_hor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_ver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_poisson_separable_filters_2d" title="Permalink to this definition"></a></dt>
<dd><p>Poisson’s equation solve in the reduced space using convolution of separable filters with no boundary treatment.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>No boundary condition treatment.</p>
<p>See <a class="reference internal" href="#src.functions.mathlib.solve_poisson_separable_filters_obj_aware_2d" title="src.functions.mathlib.solve_poisson_separable_filters_obj_aware_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_poisson_separable_filters_obj_aware_2d()</span></code></a>
and <a class="reference internal" href="#src.functions.mathlib.solve_poisson_separable_filters_wall_aware_2d" title="src.functions.mathlib.solve_poisson_separable_filters_wall_aware_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_poisson_separable_filters_wall_aware_2d()</span></code></a> for the version with boundary treatment.</p>
</div>
<p>This uses multi-rank Poisson filters for a given rank. Given the Poisson equation in the <em>matrix form</em>
<span class="math notranslate nohighlight">\(L*X=B\)</span>, the Poisson kernel <span class="math notranslate nohighlight">\(L\)</span> (in forward setup) and its inverse <span class="math notranslate nohighlight">\(L^{-1}\)</span> (in inverse setup) are
already baked into the Poisson filters. Just provide the input data matrix and the corresponding filters matching     the formulation setup you are interested in.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Order of convolution:</em></p>
<p>The convolution order using separable filters in 3D is
<span class="math notranslate nohighlight">\(F * M \approx \displaystyle\sum_{r=1}^n f_{v_r} * (f_{h_r} * M)\)</span></p>
<dl class="simple">
<dt>where</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F\)</span> - Full Poisson kernel (either <span class="math notranslate nohighlight">\(L\)</span> or <span class="math notranslate nohighlight">\(L^{-1}\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(M\)</span> - Input data field</p></li>
<li><p><span class="math notranslate nohighlight">\(f_h\)</span> - Horizontal filter extracted from <span class="math notranslate nohighlight">\(V^T\)</span> in <span class="math notranslate nohighlight">\(SVD(F) = U.S.V^T\)</span>, with <span class="math notranslate nohighlight">\(S\)</span>                 values absorbed</p></li>
<li><p><span class="math notranslate nohighlight">\(f_v\)</span> - Vertical filter extracted from <span class="math notranslate nohighlight">\(U\)</span> in <span class="math notranslate nohighlight">\(SVD(F) = U.S.V^T\)</span>, with <span class="math notranslate nohighlight">\(S\)</span>                 values absorbed</p></li>
<li><p>double subscript <span class="math notranslate nohighlight">\(_r\)</span> means the filter corresponding the current rank</p></li>
<li><p><span class="math notranslate nohighlight">\(\displaystyle\sum_{r=1}^n\)</span> is multi-rank summation (i.e. modal solutions)</p></li>
</ul>
</dd>
</dl>
<p>Filters are obtained from Eigen decomposition of <span class="math notranslate nohighlight">\(F\)</span> using Singular Value Decomposition (<em>SVD</em>)
in the Canonical Polyadic Decomposition (<em>CPD</em>) view.
The convolution order goes from the inner bracket to outer bracket, meaning first we need to
convolve <span class="math notranslate nohighlight">\(M\)</span> with the horizontal filter, then convolve the results with the vertical filter.</p>
<p>For multi-rank convolution we have separate and independent convolutions passes on <span class="math notranslate nohighlight">\(M\)</span>, then sum up
the results. The summation comes from the <em>CPD</em> view in tensor decomposition,
which makes it possible to have rank-1 kernel convolutions to get modal solutions taking care of different
frequencies in the data domain.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>DO NOT</strong> feed input data matrix <span class="math notranslate nohighlight">\(M\)</span> in outer bracket convolution.</p>
<p><strong>ALWAYS</strong> use the results of the previous convolution pass to do the next one.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix to be convolved on</p></li>
<li><p><strong>filter_hor</strong> (<em>ndarray</em>) – horizontal Poisson filters</p></li>
<li><p><strong>filter_ver</strong> (<em>ndarray</em>) – vertical Poisson filters</p></li>
<li><p><strong>safe_rank</strong> (<em>int</em>) – desired input rank. ‘safe’ means a rank that does not exceed the actual rank of the kernel.
It is the minimum of Poisson kernel <span class="math notranslate nohighlight">\(L\)</span> rows and columns.
You can also use <a class="reference internal" href="#src.functions.decompositions.rank_safety_clamp_2d" title="src.functions.decompositions.rank_safety_clamp_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">src.functions.decompositions.rank_safety_clamp_2d()</span></code></a> to set this</p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – number of lateral elements to skip in the convolution. This helps with saving computation
time when having redundant padding (Default= <code class="code docutils literal notranslate"><span class="pre">0</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the solution to Poisson’s equation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_poisson_separable_filters_from_components_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_poisson_separable_filters_from_components_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">VT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trunc_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trunc_factor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_margin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_poisson_separable_filters_from_components_2d" title="Permalink to this definition"></a></dt>
<dd><p>2D Poisson solve in a reduced space from SVD components. Filters are computed on the fly and truncated
before application.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>see <a class="reference internal" href="#src.functions.mathlib.solve_poisson_separable_filters_2d" title="src.functions.mathlib.solve_poisson_separable_filters_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_poisson_separable_filters_2d()</span></code></a> for details on filter extraction and application.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix to be convolved on</p></li>
<li><p><strong>U</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(U\)</span> in <span class="math notranslate nohighlight">\(USV^T\)</span></p></li>
<li><p><strong>S</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(S\)</span> in <span class="math notranslate nohighlight">\(USV^T\)</span></p></li>
<li><p><strong>VT</strong> (<em>ndarray</em>) – <span class="math notranslate nohighlight">\(V^T\)</span> in <span class="math notranslate nohighlight">\(USV^T\)</span></p></li>
<li><p><strong>rank</strong> (<em>int</em>) – desired rank. It will be safely clamped if larger than the input matrix actual rank.</p></li>
<li><p><strong>trunc_factor</strong> (<em>float</em>) – if the truncation method is <code class="code docutils literal notranslate"><span class="pre">PERCENTAGE</span></code> then a value in [0, 1], else fixed floating
point cut off threshold (<code class="code docutils literal notranslate"><span class="pre">FIXED_THRESHOLD</span></code>)</p></li>
<li><p><strong>trunc_method</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.TruncationMode" title="src.helper.commons.TruncationMode"><em>TruncationMode</em></a>) – <code class="code docutils literal notranslate"><span class="pre">PERCENTAGE</span></code> or <code class="code docutils literal notranslate"><span class="pre">FIXED_THRESHOLD</span></code> (<em>adaptive truncation</em>)</p></li>
<li><p><strong>skip_margin</strong> (<em>int</em>) – number of lateral elements to skip in the convolution. This helps with saving computation
time when having redundant padding (Default= <code class="code docutils literal notranslate"><span class="pre">0</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the solution to Poisson’s equation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_poisson_separable_filters_obj_aware_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_poisson_separable_filters_obj_aware_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_hor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_ver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collision_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">individual_rank</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_poisson_separable_filters_obj_aware_2d" title="Permalink to this definition"></a></dt>
<dd><p>Poisson’s equation solve in the reduced space using convolution of separable filters with Neumann
boundary treatment around in-domain solid object.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See <a class="reference internal" href="#src.functions.mathlib.solve_poisson_separable_filters_2d" title="src.functions.mathlib.solve_poisson_separable_filters_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_poisson_separable_filters_2d()</span></code></a> for explanation of doing Poisson filter convolution.</p>
</div>
<p>We use <em>Mirror Marching</em> algorithm to enforce Neumann boundary condition. See paper.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix to be convolved on</p></li>
<li><p><strong>filter_hor</strong> (<em>ndarray</em>) – horizontal Poisson filters</p></li>
<li><p><strong>filter_ver</strong> (<em>ndarray</em>) – vertical Poisson filters</p></li>
<li><p><strong>safe_rank</strong> (<em>int</em>) – desired input rank. ‘safe’ means a rank that does not exceed the actual rank of the kernel.
It is the minimum of Poisson kernel <span class="math notranslate nohighlight">\(L\)</span> rows and columns.
You can also use <a class="reference internal" href="#src.functions.decompositions.rank_safety_clamp_2d" title="src.functions.decompositions.rank_safety_clamp_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">src.functions.decompositions.rank_safety_clamp_2d()</span></code></a> to set this</p></li>
<li><p><strong>collision_mask</strong> (<em>ndarray</em>) – 2d object solid mask as in-domain collider</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options</p></li>
<li><p><strong>individual_rank</strong> (<em>int</em>) – if not None, only return the result of convolving with this single rank</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the solution to Poisson’s equation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_poisson_separable_filters_wall_aware_2d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_poisson_separable_filters_wall_aware_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_hor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_ver</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_poisson_separable_filters_wall_aware_2d" title="Permalink to this definition"></a></dt>
<dd><p>Poisson’s equation solve in the reduced space using convolution of separable filters with Neumann
boundary treatment around the domain walls (no in-domain solid object treatment).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See <a class="reference internal" href="#src.functions.mathlib.solve_poisson_separable_filters_2d" title="src.functions.mathlib.solve_poisson_separable_filters_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_poisson_separable_filters_2d()</span></code></a> for explanation of doing Poisson filter convolution.</p>
</div>
<p>We use <em>Mirror Marching</em> algorithm to enforce Neumann boundary condition. See paper.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix to be convolved on</p></li>
<li><p><strong>filter_hor</strong> (<em>ndarray</em>) – horizontal Poisson filters</p></li>
<li><p><strong>filter_ver</strong> (<em>ndarray</em>) – vertical Poisson filters</p></li>
<li><p><strong>safe_rank</strong> (<em>int</em>) – desired input rank. ‘safe’ means a rank that does not exceed the actual rank of the kernel.
It is the minimum of Poisson kernel <span class="math notranslate nohighlight">\(L\)</span> rows and columns.
You can also use <a class="reference internal" href="#src.functions.decompositions.rank_safety_clamp_2d" title="src.functions.decompositions.rank_safety_clamp_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">src.functions.decompositions.rank_safety_clamp_2d()</span></code></a> to set this</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the solution to Poisson’s equation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.solve_poisson_separable_filters_wall_aware_3d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">solve_poisson_separable_filters_wall_aware_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filters_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.solve_poisson_separable_filters_wall_aware_3d" title="Permalink to this definition"></a></dt>
<dd><p>Poisson’s equation solve in the reduced space using convolution of separable filters with Neumann
boundary treatment around the domain walls (no in-domain solid object treatment) - 3D.</p>
<p>We use <em>Mirror Marching</em> algorithm to enforce Neumann boundary condition. See paper.</p>
<p>We use multi-rank Poisson filters for a given rank. Given the Poisson equation in the <em>matrix form</em>
<span class="math notranslate nohighlight">\(L*X=B\)</span>, the Poisson kernel <span class="math notranslate nohighlight">\(L\)</span> (in forward setup) and its inverse <span class="math notranslate nohighlight">\(L^{-1}\)</span> (in inverse setup) are
already baked into the Poisson filters. Just provide the input data matrix and the corresponding filters matching
the formulation setup you are interested in.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Order of convolution:</em></p>
<p>The convolution order using separable filters in 3D is
<span class="math notranslate nohighlight">\(F * M \approx \displaystyle\sum_{r=1}^n f_{v_r} * (f_{h_r} * (f_{d_r} * M))\)</span></p>
<dl class="simple">
<dt>where</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(F\)</span> - Full Poisson kernel (either <span class="math notranslate nohighlight">\(L\)</span> or <span class="math notranslate nohighlight">\(L^{-1}\)</span>)</p></li>
<li><p><span class="math notranslate nohighlight">\(M\)</span> - Input data field (tensor)</p></li>
<li><p><span class="math notranslate nohighlight">\(f_v\)</span> - Vertical filter</p></li>
<li><p><span class="math notranslate nohighlight">\(f_h\)</span> - Horizontal filter</p></li>
<li><p><span class="math notranslate nohighlight">\(f_d\)</span> - Depth (fiber) filter</p></li>
<li><p>double subscript <span class="math notranslate nohighlight">\(_r\)</span> means the filter corresponding the current rank</p></li>
<li><p><span class="math notranslate nohighlight">\(\displaystyle\sum_{r=1}^n\)</span> is multi-rank summation (i.e. modal solutions)</p></li>
</ul>
</dd>
</dl>
<p>Filters are obtained from Tensor Eigen Decomposition of <span class="math notranslate nohighlight">\(F\)</span> using
<em>Symmetric-CP</em> (Symmetric Canonical Polyadic Decomposition). The convolution order goes from the inner
brackets to outer brackets, meaning first we need to convolve <span class="math notranslate nohighlight">\(M\)</span> with the fiber filter, then
convolve the results with the horizontal and vertical filters.</p>
<p>For multi-rank convolution we have separate and independent convolutions passes on <span class="math notranslate nohighlight">\(M\)</span>, then sum up
the results. The summation comes from the Canonical Polyadic Decomposition (<em>CPD</em>) view in tensor decomposition,
which makes it possible to have rank-1 kernel convolutions to get modal solutions taking care of different
frequencies in the data domain.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>DO NOT</strong> feed input data matrix <span class="math notranslate nohighlight">\(M\)</span> in outer bracket convolution.</p>
<p><strong>ALWAYS</strong> use the results of the previous convolution pass to do the next one.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><em>Safe Rank</em></p>
<p>While in 2D ‘safe’ means a rank that does not exceed the actual rank of the kernel, in 3D it is different.
Due to the lack of a clear definition of rank in tensor decomposition, we can pretty much ask for any rank in
the CP-vew eigen decomposition and always get something that “works”. This vagueness of a proper rank definition
in 3D is partially linked to the fact that tensor decomposition is NP-hard.</p>
<p>In this function ‘safe’ simply means the number of ranked filters we would like to include in our convolutions,
and use it to help with setting up loops etc.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 3d matrix (tensor) to be convolved on</p></li>
<li><p><strong>filters_1d</strong> (<em>ndarray</em>) – ranked (but not sorted) filters. Same filter is used for all 3 convolutional
orientations: horizontal, vertical, and fiber (depth)</p></li>
<li><p><strong>safe_rank</strong> (<em>int</em>) – the number of ranked filters to be used in convolution</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.OptionsGeneral" title="src.helper.commons.OptionsGeneral"><em>OptionsGeneral</em></a>) – general options</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the solution to Poisson’s equation</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.trim">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">trim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.trim" title="Permalink to this definition"></a></dt>
<dd><p>Trim the input 2d matrix, which will shrink equally on each side and dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input 2d matrix</p></li>
<li><p><strong>size</strong> (<em>int</em>) – trimming size</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>trimmed matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.truncate_filters">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">truncate_filters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">truncation_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">truncation_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filters_1d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.truncate_filters" title="Permalink to this definition"></a></dt>
<dd><p>Truncate filters either by <cite>PERCENTAGE</cite> or <cite>FIXED_THRESHOLD</cite> (<em>adaptive truncation</em>).</p>
<p>Poisson filters are symmetrical, hence truncation automatically implies symmetrically removing values from sides.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>truncation_method</strong> (<a class="reference internal" href="src.helper.html#src.helper.commons.TruncationMode" title="src.helper.commons.TruncationMode"><em>TruncationMode</em></a>) – <code class="code docutils literal notranslate"><span class="pre">PERCENTAGE</span></code> or <code class="code docutils literal notranslate"><span class="pre">FIXED_THRESHOLD</span></code> (<em>adaptive truncation</em>)</p></li>
<li><p><strong>truncation_value</strong> (<em>float</em>) – if the truncation method is <code class="code docutils literal notranslate"><span class="pre">PERCENTAGE</span></code> then a value in [0, 1], else         fixed floating point cut off threshold (<code class="code docutils literal notranslate"><span class="pre">FIXED_THRESHOLD</span></code>)</p></li>
<li><p><strong>safe_rank</strong> (<em>int</em>) – desired input rank. ‘safe’ means a rank that does not exceed the actual rank of the kernel</p></li>
<li><p><strong>filters_1d</strong> (<em>ndarray</em>) – </p></li>
<li><p><strong>preserve_shape</strong> (<em>bool</em>) – if True keep the original shape and fill them with zeros (Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new smaller array with truncated elements</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.truncate_fixed_threshold_1darray">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">truncate_fixed_threshold_1darray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_off</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.truncate_fixed_threshold_1darray" title="Permalink to this definition"></a></dt>
<dd><p>Adaptive truncation. Cut any elements smaller than a fixed absolute value, assuming a symmetrical filter     and values are sorted sideways from largest (center) to smallest (tales).</p>
<p>Only works with symmetrical filters, and only cuts the outer parts of the filters.</p>
<p>[….outer part…. cut || …….inner part……. || cut ….outer part….]</p>
<p>Cut elements &lt; cut_off</p>
<p>Keep elements &gt;= cut_off</p>
<p>Checking the absolute values against the absolute threshold value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>ndarray</em>) – input 1d array</p></li>
<li><p><strong>cut_off</strong> (<em>float</em>) – truncation threshold (absolute value)</p></li>
<li><p><strong>preserve_shape</strong> (<em>bool</em>) – if True keep the original shape and fill them with zeros (Default= <code class="code docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>truncated (smaller) array. If preserving the shape, keep the shape and insert zeros in the truncated parts.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.truncate_percent_filter_1d">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">truncate_percent_filter_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trunc_percent</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.truncate_percent_filter_1d" title="Permalink to this definition"></a></dt>
<dd><p>Truncate a percentage of a 1d array symmetrically.</p>
<p>It finds the middle, then throws out the truncation % from both ends. The results will be exactly symmetrical for
odd sized arrays. For arrays with an even size the middle will be the ceiling (the larger index of the pair in the
middle). For a 100% truncation the output is the middle element.</p>
<p>If truncation results in fractional elimination of an element, we assume ceiling and still eliminate that element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>ndarray</em>) – input 1d array</p></li>
<li><p><strong>trunc_percent</strong> (<em>float</em>) – truncation factor in [0, 1]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new smaller array with truncated elements</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="src.functions.mathlib.zero_out_small_values">
<span class="sig-prename descclassname"><span class="pre">src.functions.mathlib.</span></span><span class="sig-name descname"><span class="pre">zero_out_small_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.functions.mathlib.zero_out_small_values" title="Permalink to this definition"></a></dt>
<dd><p>Zero out all the elements whose absolute values are below the threshold</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>ndarray</em>) – input array</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – non-negative</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>same as input with zeros in place of small values</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="src.demos.html" class="btn btn-neutral float-left" title="src.demos package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="src.helper.html" class="btn btn-neutral float-right" title="src.helper package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Ubisoft.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>